import { DestroyRef, NgZone, inject, signal } from '@angular/core';
import { notifyManager } from '@tanstack/query-core';
import { assertInjector } from './util/assert-injector/assert-injector';
import { injectQueryClient } from './inject-query-client';
/**
 * Injects a signal that tracks the number of mutations that your application is fetching.
 *
 * Can be used for app-wide loading indicators
 * @param filters - The filters to apply to the query.
 * @param injector - The Angular injector to use.
 * @returns signal with number of fetching mutations.
 * @public
 */
export function injectIsMutating(filters, injector) {
    return assertInjector(injectIsMutating, injector, () => {
        const queryClient = injectQueryClient();
        const destroyRef = inject(DestroyRef);
        const ngZone = inject(NgZone);
        const cache = queryClient.getMutationCache();
        // isMutating is the prev value initialized on mount *
        let isMutating = queryClient.isMutating(filters);
        const result = signal(isMutating);
        const unsubscribe = cache.subscribe(notifyManager.batchCalls(() => {
            const newIsMutating = queryClient.isMutating(filters);
            if (isMutating !== newIsMutating) {
                // * and update with each change
                isMutating = newIsMutating;
                ngZone.run(() => {
                    result.set(isMutating);
                });
            }
        }));
        destroyRef.onDestroy(unsubscribe);
        return result;
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5qZWN0LWlzLW11dGF0aW5nLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2luamVjdC1pcy1tdXRhdGluZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFBO0FBQ2xFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQTtBQUNwRCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sd0NBQXdDLENBQUE7QUFDdkUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sdUJBQXVCLENBQUE7QUFJekQ7Ozs7Ozs7O0dBUUc7QUFDSCxNQUFNLFVBQVUsZ0JBQWdCLENBQzlCLE9BQXlCLEVBQ3pCLFFBQW1CO0lBRW5CLE9BQU8sY0FBYyxDQUFDLGdCQUFnQixFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUU7UUFDckQsTUFBTSxXQUFXLEdBQUcsaUJBQWlCLEVBQUUsQ0FBQTtRQUN2QyxNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUE7UUFDckMsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFBO1FBRTdCLE1BQU0sS0FBSyxHQUFHLFdBQVcsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFBO1FBQzVDLHNEQUFzRDtRQUN0RCxJQUFJLFVBQVUsR0FBRyxXQUFXLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFBO1FBRWhELE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQTtRQUVqQyxNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsU0FBUyxDQUNqQyxhQUFhLENBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRTtZQUM1QixNQUFNLGFBQWEsR0FBRyxXQUFXLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFBO1lBQ3JELElBQUksVUFBVSxLQUFLLGFBQWEsRUFBRSxDQUFDO2dCQUNqQyxnQ0FBZ0M7Z0JBQ2hDLFVBQVUsR0FBRyxhQUFhLENBQUE7Z0JBQzFCLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFO29CQUNkLE1BQU0sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUE7Z0JBQ3hCLENBQUMsQ0FBQyxDQUFBO1lBQ0osQ0FBQztRQUNILENBQUMsQ0FBQyxDQUNILENBQUE7UUFFRCxVQUFVLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxDQUFBO1FBRWpDLE9BQU8sTUFBTSxDQUFBO0lBQ2YsQ0FBQyxDQUFDLENBQUE7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVzdHJveVJlZiwgTmdab25lLCBpbmplY3QsIHNpZ25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnXG5pbXBvcnQgeyBub3RpZnlNYW5hZ2VyIH0gZnJvbSAnQHRhbnN0YWNrL3F1ZXJ5LWNvcmUnXG5pbXBvcnQgeyBhc3NlcnRJbmplY3RvciB9IGZyb20gJy4vdXRpbC9hc3NlcnQtaW5qZWN0b3IvYXNzZXJ0LWluamVjdG9yJ1xuaW1wb3J0IHsgaW5qZWN0UXVlcnlDbGllbnQgfSBmcm9tICcuL2luamVjdC1xdWVyeS1jbGllbnQnXG5pbXBvcnQgdHlwZSB7IE11dGF0aW9uRmlsdGVycyB9IGZyb20gJ0B0YW5zdGFjay9xdWVyeS1jb3JlJ1xuaW1wb3J0IHR5cGUgeyBJbmplY3RvciwgU2lnbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSdcblxuLyoqXG4gKiBJbmplY3RzIGEgc2lnbmFsIHRoYXQgdHJhY2tzIHRoZSBudW1iZXIgb2YgbXV0YXRpb25zIHRoYXQgeW91ciBhcHBsaWNhdGlvbiBpcyBmZXRjaGluZy5cbiAqXG4gKiBDYW4gYmUgdXNlZCBmb3IgYXBwLXdpZGUgbG9hZGluZyBpbmRpY2F0b3JzXG4gKiBAcGFyYW0gZmlsdGVycyAtIFRoZSBmaWx0ZXJzIHRvIGFwcGx5IHRvIHRoZSBxdWVyeS5cbiAqIEBwYXJhbSBpbmplY3RvciAtIFRoZSBBbmd1bGFyIGluamVjdG9yIHRvIHVzZS5cbiAqIEByZXR1cm5zIHNpZ25hbCB3aXRoIG51bWJlciBvZiBmZXRjaGluZyBtdXRhdGlvbnMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmplY3RJc011dGF0aW5nKFxuICBmaWx0ZXJzPzogTXV0YXRpb25GaWx0ZXJzLFxuICBpbmplY3Rvcj86IEluamVjdG9yLFxuKTogU2lnbmFsPG51bWJlcj4ge1xuICByZXR1cm4gYXNzZXJ0SW5qZWN0b3IoaW5qZWN0SXNNdXRhdGluZywgaW5qZWN0b3IsICgpID0+IHtcbiAgICBjb25zdCBxdWVyeUNsaWVudCA9IGluamVjdFF1ZXJ5Q2xpZW50KClcbiAgICBjb25zdCBkZXN0cm95UmVmID0gaW5qZWN0KERlc3Ryb3lSZWYpXG4gICAgY29uc3Qgbmdab25lID0gaW5qZWN0KE5nWm9uZSlcblxuICAgIGNvbnN0IGNhY2hlID0gcXVlcnlDbGllbnQuZ2V0TXV0YXRpb25DYWNoZSgpXG4gICAgLy8gaXNNdXRhdGluZyBpcyB0aGUgcHJldiB2YWx1ZSBpbml0aWFsaXplZCBvbiBtb3VudCAqXG4gICAgbGV0IGlzTXV0YXRpbmcgPSBxdWVyeUNsaWVudC5pc011dGF0aW5nKGZpbHRlcnMpXG5cbiAgICBjb25zdCByZXN1bHQgPSBzaWduYWwoaXNNdXRhdGluZylcblxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gY2FjaGUuc3Vic2NyaWJlKFxuICAgICAgbm90aWZ5TWFuYWdlci5iYXRjaENhbGxzKCgpID0+IHtcbiAgICAgICAgY29uc3QgbmV3SXNNdXRhdGluZyA9IHF1ZXJ5Q2xpZW50LmlzTXV0YXRpbmcoZmlsdGVycylcbiAgICAgICAgaWYgKGlzTXV0YXRpbmcgIT09IG5ld0lzTXV0YXRpbmcpIHtcbiAgICAgICAgICAvLyAqIGFuZCB1cGRhdGUgd2l0aCBlYWNoIGNoYW5nZVxuICAgICAgICAgIGlzTXV0YXRpbmcgPSBuZXdJc011dGF0aW5nXG4gICAgICAgICAgbmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICByZXN1bHQuc2V0KGlzTXV0YXRpbmcpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgKVxuXG4gICAgZGVzdHJveVJlZi5vbkRlc3Ryb3kodW5zdWJzY3JpYmUpXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pXG59XG4iXX0=