import { notifyManager, InfiniteQueryObserver, MutationObserver, replaceEqualDeep, QueriesObserver, QueryObserver } from '@tanstack/query-core';
export * from '@tanstack/query-core';
import { untracked, computed, assertInInjectionContext, inject, Injector, runInInjectionContext, InjectionToken, NgZone, DestroyRef, signal, effect, makeEnvironmentProviders, ENVIRONMENT_INITIALIZER } from '@angular/core';

/* istanbul ignore file */

/**
 * Allows to share and re-use query options in a type-safe way.
 *
 * The `queryKey` will be tagged with the type from `queryFn`.
 *
 * **Example**
 *
 * ```ts
 *  const { queryKey } = queryOptions({
 *     queryKey: ['key'],
 *     queryFn: () => Promise.resolve(5),
 *     //  ^?  Promise<number>
 *   })
 *
 *   const queryClient = new QueryClient()
 *   const data = queryClient.getQueryData(queryKey)
 *   //    ^?  number | undefined
 * ```
 * @param options - The query options to tag with the type from `queryFn`.
 * @returns The tagged query options.
 * @public
 */
function queryOptions(options) {
    return options;
}

/**
 * Allows to share and re-use infinite query options in a type-safe way.
 *
 * The `queryKey` will be tagged with the type from `queryFn`.
 * @param options - The infinite query options to tag with the type from `queryFn`.
 * @returns The tagged infinite query options.
 * @public
 */
function infiniteQueryOptions(options) {
    return options;
}

/**
 * Exposes fields of an object passed via an Angular `Signal` as `Computed` signals.
 * Functions on the object are passed through as-is.
 * @param inputSignal - `Signal` that must return an object.
 * @returns A proxy object with the same fields as the input object, but with each field wrapped in a `Computed` signal.
 */
function signalProxy(inputSignal) {
    const internalState = {};
    return new Proxy(internalState, {
        get(target, prop) {
            // first check if we have it in our internal state and return it
            const computedField = target[prop];
            if (computedField)
                return computedField;
            // then, check if it's a function on the resultState and return it
            const targetField = untracked(inputSignal)[prop];
            if (typeof targetField === 'function')
                return targetField;
            // finally, create a computed field, store it and return it
            // @ts-expect-error
            return (target[prop] = computed(() => inputSignal()[prop]));
        },
        has(_, prop) {
            return !!untracked(inputSignal)[prop];
        },
        ownKeys() {
            return Reflect.ownKeys(untracked(inputSignal));
        },
        getOwnPropertyDescriptor() {
            return {
                enumerable: true,
                configurable: true,
            };
        },
    });
}

function shouldThrowError(throwError, params) {
    // Allow throwError function to override throwing behavior on a per-error basis
    if (typeof throwError === 'function') {
        return throwError(...params);
    }
    return !!throwError;
}
function noop() { }

function lazyInit(initializer) {
    let object = null;
    const initializeObject = () => {
        if (!object) {
            object = untracked(() => initializer());
        }
    };
    queueMicrotask(() => initializeObject());
    return new Proxy({}, {
        get(_, prop, receiver) {
            initializeObject();
            return Reflect.get(object, prop, receiver);
        },
        has(_, prop) {
            initializeObject();
            return Reflect.has(object, prop);
        },
        ownKeys() {
            initializeObject();
            return Reflect.ownKeys(object);
        },
        getOwnPropertyDescriptor() {
            return {
                enumerable: true,
                configurable: true,
            };
        },
    });
}

/* eslint-disable cspell/spellchecker */
/**
 * The code in this file is adapted from NG Extension Platform at https://ngxtension.netlify.app.
 *
 * Original Author: Chau Tran
 *
 * NG Extension Platform is an open-source project licensed under the MIT license.
 *
 * For more information about the original code, see
 * https://github.com/nartc/ngxtension-platform
 */
/* eslint-enable */
function assertInjector(fn, injector, runner) {
    !injector && assertInInjectionContext(fn);
    const assertedInjector = injector ?? inject(Injector);
    if (!runner)
        return assertedInjector;
    return runInInjectionContext(assertedInjector, runner);
}

/* eslint-disable cspell/spellchecker */
/**
 * The code in this file is adapted from NG Extension Platform at https://ngxtension.netlify.app.
 *
 * Original Author: Chau Tran
 *
 * NG Extension Platform is an open-source project licensed under the MIT license.
 *
 * For more information about the original code, see
 * https://github.com/nartc/ngxtension-platform
 */
/* eslint-enable */
function createInjectFn(token) {
    return function ({ injector, ...injectOptions } = {}) {
        injector = assertInjector(this, injector);
        return runInInjectionContext(injector, () => inject(token, injectOptions));
    };
}
function createProvideFn(token, factory, opts = {}) {
    const { deps = [], multi = false, extraProviders = [] } = opts;
    return (value, isFunctionValue = false) => {
        let provider;
        if (value !== undefined) {
            // eslint-disable-next-line no-shadow
            const factory = typeof value === 'function'
                ? isFunctionValue
                    ? () => value
                    : value
                : () => value;
            provider = {
                provide: token,
                useFactory: factory,
                multi,
            };
        }
        else {
            provider = {
                provide: token,
                useFactory: factory,
                deps: deps,
                multi,
            };
        }
        return [extraProviders, provider];
    };
}
function createNoopInjectionToken(description, options) {
    const token = 
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    options?.token ||
        new InjectionToken(description);
    return [
        createInjectFn(token),
        createProvideFn(token, () => null, (options || {})),
        token,
        () => { },
    ];
}

const tokens = createNoopInjectionToken('QueryClientToken');
/**
 * Injects the `QueryClient` instance into the component or service.
 *
 * **Example**
 * ```ts
 * const queryClient = injectQueryClient();
 * ```
 * @returns The `QueryClient` instance.
 * @public
 */
const injectQueryClient = tokens[0];
/**
 * Usually {@link provideAngularQuery} is used once to set up TanStack Query and the
 * {@link https://tanstack.com/query/latest/docs/reference/QueryClient|QueryClient}
 * for the entire application. You can use `provideQueryClient` to provide a
 * different `QueryClient` instance for a part of the application.
 * @public
 */
const provideQueryClient = tokens[1];

/**
 * Base implementation for `injectQuery` and `injectInfiniteQuery`.
 */
function createBaseQuery(optionsFn, Observer) {
    const injector = inject(Injector);
    return lazyInit(() => {
        const ngZone = injector.get(NgZone);
        const destroyRef = injector.get(DestroyRef);
        const queryClient = injectQueryClient({ injector });
        /**
         * Signal that has the default options from query client applied
         * computed() is used so signals can be inserted into the options
         * making it reactive. Wrapping options in a function ensures embedded expressions
         * are preserved and can keep being applied after signal changes
         */
        const defaultedOptionsSignal = computed(() => {
            const options = runInInjectionContext(injector, () => optionsFn(queryClient));
            const defaultedOptions = queryClient.defaultQueryOptions(options);
            defaultedOptions._optimisticResults = 'optimistic';
            return defaultedOptions;
        });
        const observer = new Observer(queryClient, defaultedOptionsSignal());
        const resultSignal = signal(observer.getOptimisticResult(defaultedOptionsSignal()));
        effect(() => {
            const defaultedOptions = defaultedOptionsSignal();
            observer.setOptions(defaultedOptions, {
                // Do not notify on updates because of changes in the options because
                // these changes should already be reflected in the optimistic result.
                listeners: false,
            });
            untracked(() => {
                resultSignal.set(observer.getOptimisticResult(defaultedOptions));
            });
        }, {
            injector,
        });
        // observer.trackResult is not used as this optimization is not needed for Angular
        const unsubscribe = observer.subscribe(notifyManager.batchCalls((state) => {
            ngZone.run(() => {
                if (state.isError &&
                    !state.isFetching &&
                    // !isRestoring() && // todo: enable when client persistence is implemented
                    shouldThrowError(observer.options.throwOnError, [
                        state.error,
                        observer.getCurrentQuery(),
                    ])) {
                    throw state.error;
                }
                resultSignal.set(state);
            });
        }));
        destroyRef.onDestroy(unsubscribe);
        return signalProxy(resultSignal);
    });
}

/**
 * Injects an infinite query: a declarative dependency on an asynchronous source of data that is tied to a unique key.
 * Infinite queries can additively "load more" data onto an existing set of data or "infinite scroll"
 * @param optionsFn - A function that returns infinite query options.
 * @param injector - The Angular injector to use.
 * @returns The infinite query result.
 * @public
 */
function injectInfiniteQuery(optionsFn, injector) {
    return assertInjector(injectInfiniteQuery, injector, () => createBaseQuery(optionsFn, InfiniteQueryObserver));
}

/**
 * Injects a signal that tracks the number of queries that your application is loading or
 * fetching in the background.
 *
 * Can be used for app-wide loading indicators
 * @param filters - The filters to apply to the query.
 * @param injector - The Angular injector to use.
 * @returns signal with number of loading or fetching queries.
 * @public
 */
function injectIsFetching(filters, injector) {
    return assertInjector(injectIsFetching, injector, () => {
        const queryClient = injectQueryClient();
        const destroyRef = inject(DestroyRef);
        const ngZone = inject(NgZone);
        const cache = queryClient.getQueryCache();
        // isFetching is the prev value initialized on mount *
        let isFetching = queryClient.isFetching(filters);
        const result = signal(isFetching);
        const unsubscribe = cache.subscribe(notifyManager.batchCalls(() => {
            const newIsFetching = queryClient.isFetching(filters);
            if (isFetching !== newIsFetching) {
                // * and update with each change
                isFetching = newIsFetching;
                ngZone.run(() => {
                    result.set(isFetching);
                });
            }
        }));
        destroyRef.onDestroy(unsubscribe);
        return result;
    });
}

/**
 * Injects a signal that tracks the number of mutations that your application is fetching.
 *
 * Can be used for app-wide loading indicators
 * @param filters - The filters to apply to the query.
 * @param injector - The Angular injector to use.
 * @returns signal with number of fetching mutations.
 * @public
 */
function injectIsMutating(filters, injector) {
    return assertInjector(injectIsMutating, injector, () => {
        const queryClient = injectQueryClient();
        const destroyRef = inject(DestroyRef);
        const ngZone = inject(NgZone);
        const cache = queryClient.getMutationCache();
        // isMutating is the prev value initialized on mount *
        let isMutating = queryClient.isMutating(filters);
        const result = signal(isMutating);
        const unsubscribe = cache.subscribe(notifyManager.batchCalls(() => {
            const newIsMutating = queryClient.isMutating(filters);
            if (isMutating !== newIsMutating) {
                // * and update with each change
                isMutating = newIsMutating;
                ngZone.run(() => {
                    result.set(isMutating);
                });
            }
        }));
        destroyRef.onDestroy(unsubscribe);
        return result;
    });
}

/**
 * Injects a mutation: an imperative function that can be invoked which typically performs server side effects.
 *
 * Unlike queries, mutations are not run automatically.
 * @param optionsFn - A function that returns mutation options.
 * @param injector - The Angular injector to use.
 * @returns The mutation.
 * @public
 */
function injectMutation(optionsFn, injector) {
    return assertInjector(injectMutation, injector, () => {
        const queryClient = injectQueryClient();
        const currentInjector = inject(Injector);
        const destroyRef = inject(DestroyRef);
        const ngZone = inject(NgZone);
        return lazyInit(() => runInInjectionContext(currentInjector, () => {
            const observer = new MutationObserver(queryClient, optionsFn(queryClient));
            const mutate = (variables, mutateOptions) => {
                observer.mutate(variables, mutateOptions).catch(noop);
            };
            effect(() => {
                observer.setOptions(runInInjectionContext(currentInjector, () => optionsFn(queryClient)));
            });
            const result = signal(observer.getCurrentResult());
            const unsubscribe = observer.subscribe(notifyManager.batchCalls((state) => {
                ngZone.run(() => {
                    if (state.isError &&
                        shouldThrowError(observer.options.throwOnError, [state.error])) {
                        throw state.error;
                    }
                    result.set(state);
                });
            }));
            destroyRef.onDestroy(unsubscribe);
            const resultSignal = computed(() => ({
                ...result(),
                mutate,
                mutateAsync: result().mutate,
            }));
            return signalProxy(resultSignal);
        }));
    });
}

function lazySignalInitializer(initializerFn) {
    const injector = inject(Injector);
    let source = null;
    const unwrapSignal = () => {
        if (!source) {
            source = untracked(() => initializerFn(injector));
        }
        return source();
    };
    queueMicrotask(() => unwrapSignal());
    return computed(unwrapSignal);
}

function getResult(mutationCache, options) {
    return mutationCache
        .findAll(options.filters)
        .map((mutation) => (options.select ? options.select(mutation) : mutation.state));
}
/**
 * Injects a signal that tracks the state of all mutations.
 * @param mutationStateOptionsFn - A function that returns mutation state options.
 * @param options - The Angular injector to use.
 * @returns The signal that tracks the state of all mutations.
 * @public
 */
function injectMutationState(mutationStateOptionsFn = () => ({}), options) {
    return assertInjector(injectMutationState, options?.injector, () => {
        const destroyRef = inject(DestroyRef);
        const queryClient = injectQueryClient();
        const ngZone = inject(NgZone);
        const mutationCache = queryClient.getMutationCache();
        return lazySignalInitializer((injector) => {
            const result = signal(getResult(mutationCache, mutationStateOptionsFn()));
            effect(() => {
                const mutationStateOptions = mutationStateOptionsFn();
                untracked(() => {
                    // Setting the signal from an effect because it's both 'computed' from options()
                    // and needs to be set imperatively in the mutationCache listener.
                    result.set(getResult(mutationCache, mutationStateOptions));
                });
            }, { injector });
            const unsubscribe = mutationCache.subscribe(notifyManager.batchCalls(() => {
                const nextResult = replaceEqualDeep(result(), getResult(mutationCache, mutationStateOptionsFn()));
                if (result() !== nextResult) {
                    ngZone.run(() => {
                        result.set(nextResult);
                    });
                }
            }));
            destroyRef.onDestroy(unsubscribe);
            return result;
        });
    });
}

/**
 * @public
 */
function injectQueries({ queries, ...options }, injector) {
    return assertInjector(injectQueries, injector, () => {
        const queryClient = injectQueryClient();
        const destroyRef = inject(DestroyRef);
        const defaultedQueries = computed(() => {
            return queries().map((opts) => {
                const defaultedOptions = queryClient.defaultQueryOptions(opts);
                // Make sure the results are already in fetching state before subscribing or updating options
                defaultedOptions._optimisticResults = 'optimistic';
                return defaultedOptions;
            });
        });
        const observer = new QueriesObserver(queryClient, defaultedQueries(), options);
        // Do not notify on updates because of changes in the options because
        // these changes should already be reflected in the optimistic result.
        effect(() => {
            observer.setQueries(defaultedQueries(), options, { listeners: false });
        });
        const [, getCombinedResult] = observer.getOptimisticResult(defaultedQueries(), options.combine);
        const result = signal(getCombinedResult());
        const unsubscribe = observer.subscribe(notifyManager.batchCalls(result.set));
        destroyRef.onDestroy(unsubscribe);
        return result;
    });
}

/**
 * Injects a query: a declarative dependency on an asynchronous source of data that is tied to a unique key.
 *
 * **Basic example**
 * ```ts
 * class ServiceOrComponent {
 *   query = injectQuery(() => ({
 *     queryKey: ['repoData'],
 *     queryFn: () =>
 *       this.#http.get<Response>('https://api.github.com/repos/tanstack/query'),
 *   }))
 * }
 * ```
 *
 * Similar to `computed` from Angular, the function passed to `injectQuery` will be run in the reactive context.
 * In the example below, the query will be automatically enabled and executed when the filter signal changes
 * to a truthy value. When the filter signal changes back to a falsy value, the query will be disabled.
 *
 * **Reactive example**
 * ```ts
 * class ServiceOrComponent {
 *   filter = signal('')
 *
 *   todosQuery = injectQuery(() => ({
 *     queryKey: ['todos', this.filter()],
 *     queryFn: () => fetchTodos(this.filter()),
 *     // Signals can be combined with expressions
 *     enabled: !!this.filter(),
 *   }))
 * }
 * ```
 * @param optionsFn - A function that returns query options.
 * @param injector - The Angular injector to use.
 * @returns The query result.
 * @public
 * @see https://tanstack.com/query/latest/docs/framework/angular/guides/queries
 */
function injectQuery(optionsFn, injector) {
    return assertInjector(injectQuery, injector, () => createBaseQuery(optionsFn, QueryObserver));
}

/**
 * Sets up providers necessary to enable TanStack Query functionality for Angular applications.
 *
 * Allows to configure a `QueryClient`.
 *
 * **Example - standalone**
 *
 * ```ts
 * import {
 *   provideAngularQuery,
 *   QueryClient,
 * } from '@tanstack/angular-query-experimental'
 *
 * bootstrapApplication(AppComponent, {
 *   providers: [provideAngularQuery(new QueryClient())],
 * })
 * ```
 *
 * **Example - NgModule-based**
 *
 * ```ts
 * import {
 *   provideAngularQuery,
 *   QueryClient,
 * } from '@tanstack/angular-query-experimental'
 *
 * @NgModule({
 *   declarations: [AppComponent],
 *   imports: [BrowserModule],
 *   providers: [provideAngularQuery(new QueryClient())],
 *   bootstrap: [AppComponent],
 * })
 * export class AppModule {}
 * ```
 * @param queryClient - A `QueryClient` instance.
 * @returns A set of providers to set up TanStack Query.
 * @public
 * @see https://tanstack.com/query/v5/docs/framework/angular/quick-start
 */
function provideAngularQuery(queryClient) {
    return makeEnvironmentProviders([
        provideQueryClient(queryClient),
        {
            provide: ENVIRONMENT_INITIALIZER,
            multi: true,
            useValue: () => {
                queryClient.mount();
                // Unmount the query client on application destroy
                inject(DestroyRef).onDestroy(() => queryClient.unmount());
            },
        },
    ]);
}

/* istanbul ignore file */
// Re-export core

/**
 * Generated bundle index. Do not edit.
 */

export { infiniteQueryOptions, injectInfiniteQuery, injectIsFetching, injectIsMutating, injectMutation, injectMutationState, injectQueries, injectQuery, injectQueryClient, provideAngularQuery, provideQueryClient, queryOptions };
//# sourceMappingURL=tanstack-angular-query-experimental.mjs.map
