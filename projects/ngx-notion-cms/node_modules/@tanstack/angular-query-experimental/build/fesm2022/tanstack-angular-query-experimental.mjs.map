{"version":3,"file":"tanstack-angular-query-experimental.mjs","sources":["../../src/types.ts","../../src/query-options.ts","../../src/infinite-query-options.ts","../../src/signal-proxy.ts","../../src/util/index.ts","../../src/util/lazy-init/lazy-init.ts","../../src/util/assert-injector/assert-injector.ts","../../src/util/create-injection-token/create-injection-token.ts","../../src/inject-query-client.ts","../../src/create-base-query.ts","../../src/inject-infinite-query.ts","../../src/inject-is-fetching.ts","../../src/inject-is-mutating.ts","../../src/inject-mutation.ts","../../src/util/lazy-signal-initializer/lazy-signal-initializer.ts","../../src/inject-mutation-state.ts","../../src/inject-queries.ts","../../src/inject-query.ts","../../src/providers.ts","../../src/index.ts","../../src/tanstack-angular-query-experimental.ts"],"sourcesContent":["/* istanbul ignore file */\n\nimport type {\n  DefaultError,\n  DefinedInfiniteQueryObserverResult,\n  DefinedQueryObserverResult,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n  MutateFunction,\n  MutationObserverOptions,\n  MutationObserverResult,\n  OmitKeyof,\n  Override,\n  QueryKey,\n  QueryObserverOptions,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { Signal } from '@angular/core'\nimport type { MapToSignals } from './signal-proxy'\n\n/**\n * @public\n */\nexport interface CreateBaseQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {}\n\n/**\n * @public\n */\nexport interface CreateQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends OmitKeyof<\n    CreateBaseQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'suspense'\n  > {}\n\n/**\n * @public\n */\ntype CreateStatusBasedQueryResult<\n  TStatus extends QueryObserverResult['status'],\n  TData = unknown,\n  TError = DefaultError,\n> = Extract<QueryObserverResult<TData, TError>, { status: TStatus }>\n\n/**\n * @public\n */\nexport interface BaseQueryNarrowing<TData = unknown, TError = DefaultError> {\n  isSuccess: (\n    this: CreateBaseQueryResult<TData, TError>,\n  ) => this is CreateBaseQueryResult<\n    TData,\n    TError,\n    CreateStatusBasedQueryResult<'success', TData, TError>\n  >\n  isError: (\n    this: CreateBaseQueryResult<TData, TError>,\n  ) => this is CreateBaseQueryResult<\n    TData,\n    TError,\n    CreateStatusBasedQueryResult<'error', TData, TError>\n  >\n  isPending: (\n    this: CreateBaseQueryResult<TData, TError>,\n  ) => this is CreateBaseQueryResult<\n    TData,\n    TError,\n    CreateStatusBasedQueryResult<'pending', TData, TError>\n  >\n}\n\n/**\n * @public\n */\nexport interface CreateInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends OmitKeyof<\n    InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n    'suspense'\n  > {}\n\n/**\n * @public\n */\nexport type CreateBaseQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n  TState = QueryObserverResult<TData, TError>,\n> = BaseQueryNarrowing<TData, TError> &\n  MapToSignals<OmitKeyof<TState, keyof BaseQueryNarrowing, 'safely'>>\n\n/**\n * @public\n */\nexport type CreateQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = CreateBaseQueryResult<TData, TError>\n\n/**\n * @public\n */\nexport type DefinedCreateQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n  TDefinedQueryObserver = DefinedQueryObserverResult<TData, TError>,\n> = MapToSignals<TDefinedQueryObserver>\n\n/**\n * @public\n */\nexport type CreateInfiniteQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = MapToSignals<InfiniteQueryObserverResult<TData, TError>>\n\n/**\n * @public\n */\nexport type DefinedCreateInfiniteQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n  TDefinedInfiniteQueryObserver = DefinedInfiniteQueryObserverResult<\n    TData,\n    TError\n  >,\n> = MapToSignals<TDefinedInfiniteQueryObserver>\n\n/**\n * @public\n */\nexport interface CreateMutationOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends OmitKeyof<\n    MutationObserverOptions<TData, TError, TVariables, TContext>,\n    '_defaulted'\n  > {}\n\n/**\n * @public\n */\nexport type CreateMutateFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = (\n  ...args: Parameters<MutateFunction<TData, TError, TVariables, TContext>>\n) => void\n\n/**\n * @public\n */\nexport type CreateMutateAsyncFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = MutateFunction<TData, TError, TVariables, TContext>\n\n/**\n * @public\n */\nexport type CreateBaseMutationResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> = Override<\n  MutationObserverResult<TData, TError, TVariables, TContext>,\n  { mutate: CreateMutateFunction<TData, TError, TVariables, TContext> }\n> & {\n  mutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TContext>\n}\n\n/**\n * @public\n */\ntype CreateStatusBasedMutationResult<\n  TStatus extends CreateBaseMutationResult['status'],\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> = Extract<\n  CreateBaseMutationResult<TData, TError, TVariables, TContext>,\n  { status: TStatus }\n>\n\ntype SignalFunction<T extends () => any> = T & Signal<ReturnType<T>>\n\n/**\n * @public\n */\nexport interface BaseMutationNarrowing<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> {\n  isSuccess: SignalFunction<\n    (\n      this: CreateMutationResult<TData, TError, TVariables, TContext>,\n    ) => this is CreateMutationResult<\n      TData,\n      TError,\n      TVariables,\n      TContext,\n      CreateStatusBasedMutationResult<\n        'success',\n        TData,\n        TError,\n        TVariables,\n        TContext\n      >\n    >\n  >\n  isError: SignalFunction<\n    (\n      this: CreateMutationResult<TData, TError, TVariables, TContext>,\n    ) => this is CreateMutationResult<\n      TData,\n      TError,\n      TVariables,\n      TContext,\n      CreateStatusBasedMutationResult<\n        'error',\n        TData,\n        TError,\n        TVariables,\n        TContext\n      >\n    >\n  >\n  isPending: SignalFunction<\n    (\n      this: CreateMutationResult<TData, TError, TVariables, TContext>,\n    ) => this is CreateMutationResult<\n      TData,\n      TError,\n      TVariables,\n      TContext,\n      CreateStatusBasedMutationResult<\n        'pending',\n        TData,\n        TError,\n        TVariables,\n        TContext\n      >\n    >\n  >\n  isIdle: SignalFunction<\n    (\n      this: CreateMutationResult<TData, TError, TVariables, TContext>,\n    ) => this is CreateMutationResult<\n      TData,\n      TError,\n      TVariables,\n      TContext,\n      CreateStatusBasedMutationResult<\n        'idle',\n        TData,\n        TError,\n        TVariables,\n        TContext\n      >\n    >\n  >\n}\n\n/**\n * @public\n */\nexport type CreateMutationResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n  TState = CreateStatusBasedMutationResult<\n    CreateBaseMutationResult['status'],\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >,\n> = BaseMutationNarrowing<TData, TError, TVariables, TContext> &\n  MapToSignals<OmitKeyof<TState, keyof BaseMutationNarrowing, 'safely'>>\n\n/**\n * @public\n */\nexport type NonUndefinedGuard<T> = T extends undefined ? never : T\n","import type {\n  DataTag,\n  DefaultError,\n  InitialDataFunction,\n  QueryKey,\n} from '@tanstack/query-core'\nimport type { CreateQueryOptions, NonUndefinedGuard } from './types'\n\n/**\n * @public\n */\nexport type UndefinedInitialDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  initialData?: undefined | InitialDataFunction<NonUndefinedGuard<TQueryFnData>>\n}\n\n/**\n * @public\n */\nexport type DefinedInitialDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  initialData:\n    | NonUndefinedGuard<TQueryFnData>\n    | (() => NonUndefinedGuard<TQueryFnData>)\n}\n\n/**\n * Allows to share and re-use query options in a type-safe way.\n *\n * The `queryKey` will be tagged with the type from `queryFn`.\n *\n * **Example**\n *\n * ```ts\n *  const { queryKey } = queryOptions({\n *     queryKey: ['key'],\n *     queryFn: () => Promise.resolve(5),\n *     //  ^?  Promise<number>\n *   })\n *\n *   const queryClient = new QueryClient()\n *   const data = queryClient.getQueryData(queryKey)\n *   //    ^?  number | undefined\n * ```\n * @param options - The query options to tag with the type from `queryFn`.\n * @returns The tagged query options.\n * @public\n */\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n): DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TQueryFnData>\n}\n\n/**\n * Allows to share and re-use query options in a type-safe way.\n *\n * The `queryKey` will be tagged with the type from `queryFn`.\n *\n * **Example**\n *\n * ```ts\n *  const { queryKey } = queryOptions({\n *     queryKey: ['key'],\n *     queryFn: () => Promise.resolve(5),\n *     //  ^?  Promise<number>\n *   })\n *\n *   const queryClient = new QueryClient()\n *   const data = queryClient.getQueryData(queryKey)\n *   //    ^?  number | undefined\n * ```\n * @param options - The query options to tag with the type from `queryFn`.\n * @returns The tagged query options.\n * @public\n */\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TQueryFnData>\n}\n\n/**\n * Allows to share and re-use query options in a type-safe way.\n *\n * The `queryKey` will be tagged with the type from `queryFn`.\n *\n * **Example**\n *\n * ```ts\n *  const { queryKey } = queryOptions({\n *     queryKey: ['key'],\n *     queryFn: () => Promise.resolve(5),\n *     //  ^?  Promise<number>\n *   })\n *\n *   const queryClient = new QueryClient()\n *   const data = queryClient.getQueryData(queryKey)\n *   //    ^?  number | undefined\n * ```\n * @param options - The query options to tag with the type from `queryFn`.\n * @returns The tagged query options.\n * @public\n */\nexport function queryOptions(options: unknown) {\n  return options\n}\n","import type {\n  DataTag,\n  DefaultError,\n  InfiniteData,\n  QueryKey,\n} from '@tanstack/query-core'\nimport type { CreateInfiniteQueryOptions, NonUndefinedGuard } from './types'\n\n/**\n * @public\n */\nexport type UndefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = CreateInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryFnData,\n  TQueryKey,\n  TPageParam\n> & {\n  initialData?: undefined\n}\n\n/**\n * @public\n */\nexport type DefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = CreateInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryFnData,\n  TQueryKey,\n  TPageParam\n> & {\n  initialData:\n    | NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>\n    | (() => NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>)\n}\n\n/**\n * Allows to share and re-use infinite query options in a type-safe way.\n *\n * The `queryKey` will be tagged with the type from `queryFn`.\n * @param options - The infinite query options to tag with the type from `queryFn`.\n * @returns The tagged infinite query options.\n * @public\n */\nexport function infiniteQueryOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: DefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n): DefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  queryKey: DataTag<TQueryKey, InfiniteData<TQueryFnData>>\n}\n\n/**\n * Allows to share and re-use infinite query options in a type-safe way.\n *\n * The `queryKey` will be tagged with the type from `queryFn`.\n * @param options - The infinite query options to tag with the type from `queryFn`.\n * @returns The tagged infinite query options.\n * @public\n */\nexport function infiniteQueryOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UndefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n): UndefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  queryKey: DataTag<TQueryKey, InfiniteData<TQueryFnData>>\n}\n\n/**\n * Allows to share and re-use infinite query options in a type-safe way.\n *\n * The `queryKey` will be tagged with the type from `queryFn`.\n * @param options - The infinite query options to tag with the type from `queryFn`.\n * @returns The tagged infinite query options.\n * @public\n */\nexport function infiniteQueryOptions(options: unknown) {\n  return options\n}\n","import { computed, untracked } from '@angular/core'\nimport type { Signal } from '@angular/core'\n\nexport type MapToSignals<T> = {\n  [K in keyof T]: T[K] extends Function ? T[K] : Signal<T[K]>\n}\n\n/**\n * Exposes fields of an object passed via an Angular `Signal` as `Computed` signals.\n * Functions on the object are passed through as-is.\n * @param inputSignal - `Signal` that must return an object.\n * @returns A proxy object with the same fields as the input object, but with each field wrapped in a `Computed` signal.\n */\nexport function signalProxy<TInput extends Record<string | symbol, any>>(\n  inputSignal: Signal<TInput>,\n) {\n  const internalState = {} as MapToSignals<TInput>\n\n  return new Proxy<MapToSignals<TInput>>(internalState, {\n    get(target, prop) {\n      // first check if we have it in our internal state and return it\n      const computedField = target[prop]\n      if (computedField) return computedField\n\n      // then, check if it's a function on the resultState and return it\n      const targetField = untracked(inputSignal)[prop]\n      if (typeof targetField === 'function') return targetField\n\n      // finally, create a computed field, store it and return it\n      // @ts-expect-error\n      return (target[prop] = computed(() => inputSignal()[prop]))\n    },\n    has(_, prop) {\n      return !!untracked(inputSignal)[prop]\n    },\n    ownKeys() {\n      return Reflect.ownKeys(untracked(inputSignal))\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true,\n      }\n    },\n  })\n}\n","export function shouldThrowError<T extends (...args: Array<any>) => boolean>(\n  throwError: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow throwError function to override throwing behavior on a per-error basis\n  if (typeof throwError === 'function') {\n    return throwError(...params)\n  }\n\n  return !!throwError\n}\n\nexport function noop() {}\n","import { untracked } from '@angular/core'\n\nexport function lazyInit<T extends object>(initializer: () => T): T {\n  let object: T | null = null\n\n  const initializeObject = () => {\n    if (!object) {\n      object = untracked(() => initializer())\n    }\n  }\n\n  queueMicrotask(() => initializeObject())\n\n  return new Proxy<T>({} as T, {\n    get(_, prop, receiver) {\n      initializeObject()\n      return Reflect.get(object as T, prop, receiver)\n    },\n    has(_, prop) {\n      initializeObject()\n      return Reflect.has(object as T, prop)\n    },\n    ownKeys() {\n      initializeObject()\n      return Reflect.ownKeys(object as T)\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true,\n      }\n    },\n  })\n}\n","/* eslint-disable cspell/spellchecker */\n/**\n * The code in this file is adapted from NG Extension Platform at https://ngxtension.netlify.app.\n *\n * Original Author: Chau Tran\n *\n * NG Extension Platform is an open-source project licensed under the MIT license.\n *\n * For more information about the original code, see\n * https://github.com/nartc/ngxtension-platform\n */\n/* eslint-enable */\n\nimport {\n  Injector,\n  assertInInjectionContext,\n  inject,\n  runInInjectionContext,\n} from '@angular/core'\n\n/**\n * `assertInjector` extends `assertInInjectionContext` with an optional `Injector`\n * After assertion, `assertInjector` runs the `runner` function with the guaranteed `Injector`\n * whether it is the default `Injector` within the current **Injection Context**\n * or the custom `Injector` that was passed in.\n *\n * @template {() => any} Runner - Runner is a function that can return anything\n * @param {Function} fn - the Function to pass in `assertInInjectionContext`\n * @param {Injector | undefined | null} injector - the optional \"custom\" Injector\n * @param {Runner} runner - the runner fn\n * @returns {ReturnType<Runner>} result - returns the result of the Runner\n *\n * @example\n * ```ts\n * function injectValue(injector?: Injector) {\n *  return assertInjector(injectValue, injector, () => 'value');\n * }\n *\n * injectValue(); // string\n * ```\n */\nexport function assertInjector<TRunner extends () => any>(\n  fn: Function,\n  injector: Injector | undefined | null,\n  runner: TRunner,\n): ReturnType<TRunner>\n/**\n * `assertInjector` extends `assertInInjectionContext` with an optional `Injector`\n * After assertion, `assertInjector` returns a guaranteed `Injector` whether it is the default `Injector`\n * within the current **Injection Context** or the custom `Injector` that was passed in.\n *\n * @param {Function} fn - the Function to pass in `assertInInjectionContext`\n * @param {Injector | undefined | null} injector - the optional \"custom\" Injector\n * @returns Injector\n *\n * @example\n * ```ts\n * function injectDestroy(injector?: Injector) {\n *  injector = assertInjector(injectDestroy, injector);\n *\n *  return runInInjectionContext(injector, () => {\n *    // code\n *  })\n * }\n * ```\n */\nexport function assertInjector(\n  fn: Function,\n  injector: Injector | undefined | null,\n): Injector\nexport function assertInjector(\n  fn: Function,\n  injector: Injector | undefined | null,\n  runner?: () => any,\n) {\n  !injector && assertInInjectionContext(fn)\n  const assertedInjector = injector ?? inject(Injector)\n\n  if (!runner) return assertedInjector\n  return runInInjectionContext(assertedInjector, runner)\n}\n","/* eslint-disable cspell/spellchecker */\n/**\n * The code in this file is adapted from NG Extension Platform at https://ngxtension.netlify.app.\n *\n * Original Author: Chau Tran\n *\n * NG Extension Platform is an open-source project licensed under the MIT license.\n *\n * For more information about the original code, see\n * https://github.com/nartc/ngxtension-platform\n */\n/* eslint-enable */\n\nimport { InjectionToken, inject, runInInjectionContext } from '@angular/core'\nimport { assertInjector } from '../assert-injector/assert-injector'\nimport type {\n  EnvironmentProviders,\n  FactoryProvider,\n  Host,\n  InjectOptions,\n  Injector,\n  Optional,\n  Provider,\n  Self,\n  SkipSelf,\n  Type,\n} from '@angular/core'\n\ntype CreateInjectionTokenDep<TTokenType> =\n  | Type<TTokenType>\n  // NOTE: we don't have an AbstractType\n  | (abstract new (...args: Array<any>) => TTokenType)\n  | InjectionToken<TTokenType>\n\ntype CreateInjectionTokenDeps<\n  TFactory extends (...args: Array<any>) => any,\n  TFactoryDeps extends Parameters<TFactory> = Parameters<TFactory>,\n> = {\n  [Index in keyof TFactoryDeps]:\n    | CreateInjectionTokenDep<TFactoryDeps[Index]>\n    | [\n        ...modifiers: Array<Optional | Self | SkipSelf | Host>,\n        token: CreateInjectionTokenDep<TFactoryDeps[Index]>,\n      ]\n} & { length: TFactoryDeps['length'] }\n\ntype CreateInjectionTokenOptions<\n  TFactory extends (...args: Array<any>) => any,\n  TFactoryDeps extends Parameters<TFactory> = Parameters<TFactory>,\n> =\n  // this means TFunction has no parameters\n  (TFactoryDeps[0] extends undefined\n    ? { deps?: never }\n    : { deps: CreateInjectionTokenDeps<TFactory, TFactoryDeps> }) & {\n    isRoot?: boolean\n    multi?: boolean\n    token?: InjectionToken<ReturnType<TFactory>>\n    extraProviders?: Provider | EnvironmentProviders\n  }\n\ntype CreateProvideFnOptions<\n  TFactory extends (...args: Array<any>) => any,\n  TFactoryDeps extends Parameters<TFactory> = Parameters<TFactory>,\n> = Pick<\n  CreateInjectionTokenOptions<TFactory, TFactoryDeps>,\n  'deps' | 'extraProviders' | 'multi'\n>\n\ntype InjectFn<TFactoryReturn> = {\n  (): TFactoryReturn\n  (\n    injectOptions: InjectOptions & { optional?: false } & {\n      injector?: Injector\n    },\n  ): TFactoryReturn\n  (\n    injectOptions: InjectOptions & { injector?: Injector },\n  ): TFactoryReturn | null\n}\n\ntype ProvideFn<\n  TNoop extends boolean,\n  TFactoryReturn,\n  TReturn = TFactoryReturn extends Array<infer Item> ? Item : TFactoryReturn,\n> = (TNoop extends true\n  ? (value: TReturn | (() => TReturn)) => Provider\n  : () => Provider) &\n  (TReturn extends Function\n    ? (value: TReturn | (() => TReturn), isFunctionValue: boolean) => Provider\n    : (value: TReturn | (() => TReturn)) => Provider)\n\ntype CreateInjectionTokenReturn<\n  TFactoryReturn,\n  TNoop extends boolean = false,\n> = [\n  InjectFn<TFactoryReturn>,\n  ProvideFn<TNoop, TFactoryReturn>,\n  InjectionToken<TFactoryReturn>,\n  () => Provider,\n]\n\nfunction createInjectFn<TValue>(token: InjectionToken<TValue>) {\n  return function (\n    this: Function,\n    {\n      injector,\n      ...injectOptions\n    }: InjectOptions & { injector?: Injector } = {},\n  ) {\n    injector = assertInjector(this, injector)\n    return runInInjectionContext(injector, () =>\n      inject(token, injectOptions as InjectOptions),\n    )\n  }\n}\n\nfunction createProvideFn<\n  TValue,\n  TFactory extends (...args: Array<any>) => any = (\n    ...args: Array<any>\n  ) => TValue,\n  TFactoryDeps extends Parameters<TFactory> = Parameters<TFactory>,\n>(\n  token: InjectionToken<TValue>,\n  factory: (...args: Array<any>) => TValue,\n  opts: CreateProvideFnOptions<TFactory, TFactoryDeps> = {},\n) {\n  const { deps = [], multi = false, extraProviders = [] } = opts\n  return (value?: TValue | (() => TValue), isFunctionValue = false) => {\n    let provider: Provider\n    if (value !== undefined) {\n      // eslint-disable-next-line no-shadow\n      const factory =\n        typeof value === 'function'\n          ? isFunctionValue\n            ? () => value\n            : value\n          : () => value\n\n      provider = {\n        provide: token,\n        useFactory: factory,\n        multi,\n      }\n    } else {\n      provider = {\n        provide: token,\n        useFactory: factory,\n        deps: deps as FactoryProvider['deps'],\n        multi,\n      }\n    }\n\n    return [extraProviders, provider]\n  }\n}\n\nexport function createNoopInjectionToken<\n  TValue,\n  TMulti extends boolean = false,\n  TOptions = Pick<\n    CreateInjectionTokenOptions<() => void, []>,\n    'extraProviders'\n  > &\n    (TMulti extends true ? { multi: true } : Record<string, never>),\n>(description: string, options?: TOptions) {\n  type TReturn = TMulti extends true ? Array<TValue> : TValue\n\n  const token =\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    (options as CreateInjectionTokenOptions<() => void, []>)?.token ||\n    new InjectionToken<TReturn>(description)\n  return [\n    createInjectFn(token) as CreateInjectionTokenReturn<TReturn, true>[0],\n    createProvideFn(\n      token,\n      () => null!,\n      (options || {}) as CreateProvideFnOptions<() => void, []>,\n    ) as CreateInjectionTokenReturn<TReturn, true>[1],\n    token,\n    () => {},\n  ] as CreateInjectionTokenReturn<TReturn, true>\n}\n","import { createNoopInjectionToken } from './util/create-injection-token/create-injection-token'\nimport type { QueryClient } from '@tanstack/query-core'\n\nconst tokens = createNoopInjectionToken<QueryClient>('QueryClientToken')\n\n/**\n * Injects the `QueryClient` instance into the component or service.\n *\n * **Example**\n * ```ts\n * const queryClient = injectQueryClient();\n * ```\n * @returns The `QueryClient` instance.\n * @public\n */\nexport const injectQueryClient = tokens[0]\n\n/**\n * Usually {@link provideAngularQuery} is used once to set up TanStack Query and the\n * {@link https://tanstack.com/query/latest/docs/reference/QueryClient|QueryClient}\n * for the entire application. You can use `provideQueryClient` to provide a\n * different `QueryClient` instance for a part of the application.\n * @public\n */\nexport const provideQueryClient = tokens[1]\n","import {\n  DestroyRef,\n  Injector,\n  NgZone,\n  computed,\n  effect,\n  inject,\n  runInInjectionContext,\n  signal,\n  untracked,\n} from '@angular/core'\nimport { notifyManager } from '@tanstack/query-core'\nimport { signalProxy } from './signal-proxy'\nimport { shouldThrowError } from './util'\nimport { lazyInit } from './util/lazy-init/lazy-init'\nimport { injectQueryClient } from './inject-query-client'\nimport type {\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { CreateBaseQueryOptions, CreateBaseQueryResult } from './types'\n\n/**\n * Base implementation for `injectQuery` and `injectInfiniteQuery`.\n */\nexport function createBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  optionsFn: (\n    client: QueryClient,\n  ) => CreateBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n): CreateBaseQueryResult<TData, TError> {\n  const injector = inject(Injector)\n  return lazyInit(() => {\n    const ngZone = injector.get(NgZone)\n    const destroyRef = injector.get(DestroyRef)\n    const queryClient = injectQueryClient({ injector })\n\n    /**\n     * Signal that has the default options from query client applied\n     * computed() is used so signals can be inserted into the options\n     * making it reactive. Wrapping options in a function ensures embedded expressions\n     * are preserved and can keep being applied after signal changes\n     */\n    const defaultedOptionsSignal = computed(() => {\n      const options = runInInjectionContext(injector, () =>\n        optionsFn(queryClient),\n      )\n      const defaultedOptions = queryClient.defaultQueryOptions(options)\n      defaultedOptions._optimisticResults = 'optimistic'\n      return defaultedOptions\n    })\n\n    const observer = new Observer<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >(queryClient, defaultedOptionsSignal())\n\n    const resultSignal = signal(\n      observer.getOptimisticResult(defaultedOptionsSignal()),\n    )\n\n    effect(\n      () => {\n        const defaultedOptions = defaultedOptionsSignal()\n        observer.setOptions(defaultedOptions, {\n          // Do not notify on updates because of changes in the options because\n          // these changes should already be reflected in the optimistic result.\n          listeners: false,\n        })\n        untracked(() => {\n          resultSignal.set(observer.getOptimisticResult(defaultedOptions))\n        })\n      },\n      {\n        injector,\n      },\n    )\n\n    // observer.trackResult is not used as this optimization is not needed for Angular\n    const unsubscribe = observer.subscribe(\n      notifyManager.batchCalls((state: QueryObserverResult<TData, TError>) => {\n        ngZone.run(() => {\n          if (\n            state.isError &&\n            !state.isFetching &&\n            // !isRestoring() && // todo: enable when client persistence is implemented\n            shouldThrowError(observer.options.throwOnError, [\n              state.error,\n              observer.getCurrentQuery(),\n            ])\n          ) {\n            throw state.error\n          }\n          resultSignal.set(state)\n        })\n      }),\n    )\n    destroyRef.onDestroy(unsubscribe)\n\n    return signalProxy(resultSignal) as CreateBaseQueryResult<TData, TError>\n  })\n}\n","import { InfiniteQueryObserver } from '@tanstack/query-core'\nimport { createBaseQuery } from './create-base-query'\nimport { assertInjector } from './util/assert-injector/assert-injector'\nimport type { Injector } from '@angular/core'\nimport type {\n  DefaultError,\n  InfiniteData,\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n} from '@tanstack/query-core'\nimport type {\n  CreateInfiniteQueryOptions,\n  CreateInfiniteQueryResult,\n  DefinedCreateInfiniteQueryResult,\n} from './types'\nimport type {\n  DefinedInitialDataInfiniteOptions,\n  UndefinedInitialDataInfiniteOptions,\n} from './infinite-query-options'\n\n/**\n * Injects an infinite query: a declarative dependency on an asynchronous source of data that is tied to a unique key.\n * Infinite queries can additively \"load more\" data onto an existing set of data or \"infinite scroll\"\n * @param optionsFn - A function that returns infinite query options.\n * @param injector - The Angular injector to use.\n * @returns The infinite query result.\n * @public\n */\nexport function injectInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  optionsFn: (\n    client: QueryClient,\n  ) => DefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  injector?: Injector,\n): DefinedCreateInfiniteQueryResult<TData, TError>\n\n/**\n * Injects an infinite query: a declarative dependency on an asynchronous source of data that is tied to a unique key.\n * Infinite queries can additively \"load more\" data onto an existing set of data or \"infinite scroll\"\n * @param optionsFn - A function that returns infinite query options.\n * @param injector - The Angular injector to use.\n * @returns The infinite query result.\n * @public\n */\nexport function injectInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  optionsFn: (\n    client: QueryClient,\n  ) => UndefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  injector?: Injector,\n): CreateInfiniteQueryResult<TData, TError>\n\n/**\n * Injects an infinite query: a declarative dependency on an asynchronous source of data that is tied to a unique key.\n * Infinite queries can additively \"load more\" data onto an existing set of data or \"infinite scroll\"\n * @param optionsFn - A function that returns infinite query options.\n * @param injector - The Angular injector to use.\n * @returns The infinite query result.\n * @public\n */\nexport function injectInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  optionsFn: (\n    client: QueryClient,\n  ) => CreateInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey,\n    TPageParam\n  >,\n  injector?: Injector,\n): CreateInfiniteQueryResult<TData, TError>\n\n/**\n * Injects an infinite query: a declarative dependency on an asynchronous source of data that is tied to a unique key.\n * Infinite queries can additively \"load more\" data onto an existing set of data or \"infinite scroll\"\n * @param optionsFn - A function that returns infinite query options.\n * @param injector - The Angular injector to use.\n * @returns The infinite query result.\n * @public\n */\nexport function injectInfiniteQuery(\n  optionsFn: (client: QueryClient) => CreateInfiniteQueryOptions,\n  injector?: Injector,\n) {\n  return assertInjector(injectInfiniteQuery, injector, () =>\n    createBaseQuery(optionsFn, InfiniteQueryObserver as typeof QueryObserver),\n  )\n}\n","import { DestroyRef, NgZone, inject, signal } from '@angular/core'\nimport { notifyManager } from '@tanstack/query-core'\nimport { assertInjector } from './util/assert-injector/assert-injector'\nimport { injectQueryClient } from './inject-query-client'\nimport type { QueryFilters } from '@tanstack/query-core'\nimport type { Injector, Signal } from '@angular/core'\n\n/**\n * Injects a signal that tracks the number of queries that your application is loading or\n * fetching in the background.\n *\n * Can be used for app-wide loading indicators\n * @param filters - The filters to apply to the query.\n * @param injector - The Angular injector to use.\n * @returns signal with number of loading or fetching queries.\n * @public\n */\nexport function injectIsFetching(\n  filters?: QueryFilters,\n  injector?: Injector,\n): Signal<number> {\n  return assertInjector(injectIsFetching, injector, () => {\n    const queryClient = injectQueryClient()\n    const destroyRef = inject(DestroyRef)\n    const ngZone = inject(NgZone)\n\n    const cache = queryClient.getQueryCache()\n    // isFetching is the prev value initialized on mount *\n    let isFetching = queryClient.isFetching(filters)\n\n    const result = signal(isFetching)\n\n    const unsubscribe = cache.subscribe(\n      notifyManager.batchCalls(() => {\n        const newIsFetching = queryClient.isFetching(filters)\n        if (isFetching !== newIsFetching) {\n          // * and update with each change\n          isFetching = newIsFetching\n          ngZone.run(() => {\n            result.set(isFetching)\n          })\n        }\n      }),\n    )\n\n    destroyRef.onDestroy(unsubscribe)\n\n    return result\n  })\n}\n","import { DestroyRef, NgZone, inject, signal } from '@angular/core'\nimport { notifyManager } from '@tanstack/query-core'\nimport { assertInjector } from './util/assert-injector/assert-injector'\nimport { injectQueryClient } from './inject-query-client'\nimport type { MutationFilters } from '@tanstack/query-core'\nimport type { Injector, Signal } from '@angular/core'\n\n/**\n * Injects a signal that tracks the number of mutations that your application is fetching.\n *\n * Can be used for app-wide loading indicators\n * @param filters - The filters to apply to the query.\n * @param injector - The Angular injector to use.\n * @returns signal with number of fetching mutations.\n * @public\n */\nexport function injectIsMutating(\n  filters?: MutationFilters,\n  injector?: Injector,\n): Signal<number> {\n  return assertInjector(injectIsMutating, injector, () => {\n    const queryClient = injectQueryClient()\n    const destroyRef = inject(DestroyRef)\n    const ngZone = inject(NgZone)\n\n    const cache = queryClient.getMutationCache()\n    // isMutating is the prev value initialized on mount *\n    let isMutating = queryClient.isMutating(filters)\n\n    const result = signal(isMutating)\n\n    const unsubscribe = cache.subscribe(\n      notifyManager.batchCalls(() => {\n        const newIsMutating = queryClient.isMutating(filters)\n        if (isMutating !== newIsMutating) {\n          // * and update with each change\n          isMutating = newIsMutating\n          ngZone.run(() => {\n            result.set(isMutating)\n          })\n        }\n      }),\n    )\n\n    destroyRef.onDestroy(unsubscribe)\n\n    return result\n  })\n}\n","import {\n  DestroyRef,\n  Injector,\n  NgZone,\n  computed,\n  effect,\n  inject,\n  runInInjectionContext,\n  signal,\n} from '@angular/core'\nimport { MutationObserver, notifyManager } from '@tanstack/query-core'\nimport { assertInjector } from './util/assert-injector/assert-injector'\nimport { signalProxy } from './signal-proxy'\nimport { injectQueryClient } from './inject-query-client'\nimport { noop, shouldThrowError } from './util'\n\nimport { lazyInit } from './util/lazy-init/lazy-init'\nimport type {\n  DefaultError,\n  MutationObserverResult,\n  QueryClient,\n} from '@tanstack/query-core'\nimport type {\n  CreateMutateFunction,\n  CreateMutationOptions,\n  CreateMutationResult,\n} from './types'\n\n/**\n * Injects a mutation: an imperative function that can be invoked which typically performs server side effects.\n *\n * Unlike queries, mutations are not run automatically.\n * @param optionsFn - A function that returns mutation options.\n * @param injector - The Angular injector to use.\n * @returns The mutation.\n * @public\n */\nexport function injectMutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n>(\n  optionsFn: (\n    client: QueryClient,\n  ) => CreateMutationOptions<TData, TError, TVariables, TContext>,\n  injector?: Injector,\n): CreateMutationResult<TData, TError, TVariables, TContext> {\n  return assertInjector(injectMutation, injector, () => {\n    const queryClient = injectQueryClient()\n    const currentInjector = inject(Injector)\n    const destroyRef = inject(DestroyRef)\n    const ngZone = inject(NgZone)\n\n    return lazyInit(() =>\n      runInInjectionContext(currentInjector, () => {\n        const observer = new MutationObserver<\n          TData,\n          TError,\n          TVariables,\n          TContext\n        >(queryClient, optionsFn(queryClient))\n        const mutate: CreateMutateFunction<\n          TData,\n          TError,\n          TVariables,\n          TContext\n        > = (variables, mutateOptions) => {\n          observer.mutate(variables, mutateOptions).catch(noop)\n        }\n\n        effect(() => {\n          observer.setOptions(\n            runInInjectionContext(currentInjector, () =>\n              optionsFn(queryClient),\n            ),\n          )\n        })\n\n        const result = signal(observer.getCurrentResult())\n\n        const unsubscribe = observer.subscribe(\n          notifyManager.batchCalls(\n            (\n              state: MutationObserverResult<\n                TData,\n                TError,\n                TVariables,\n                TContext\n              >,\n            ) => {\n              ngZone.run(() => {\n                if (\n                  state.isError &&\n                  shouldThrowError(observer.options.throwOnError, [state.error])\n                ) {\n                  throw state.error\n                }\n                result.set(state)\n              })\n            },\n          ),\n        )\n\n        destroyRef.onDestroy(unsubscribe)\n\n        const resultSignal = computed(() => ({\n          ...result(),\n          mutate,\n          mutateAsync: result().mutate,\n        }))\n\n        return signalProxy(resultSignal) as unknown as CreateMutationResult<\n          TData,\n          TError,\n          TVariables,\n          TContext\n        >\n      }),\n    )\n  })\n}\n","import { Injector, computed, inject, untracked } from '@angular/core'\nimport type { Signal } from '@angular/core'\n\ntype SignalInitializerFn<T> = (injector: Injector) => Signal<T>\n\nexport function lazySignalInitializer<T>(\n  initializerFn: SignalInitializerFn<T>,\n) {\n  const injector = inject(Injector)\n\n  let source: Signal<T> | null = null\n\n  const unwrapSignal = () => {\n    if (!source) {\n      source = untracked(() => initializerFn(injector))\n    }\n    return source()\n  }\n\n  queueMicrotask(() => unwrapSignal())\n\n  return computed(unwrapSignal)\n}\n","import {\n  DestroyRef,\n  NgZone,\n  effect,\n  inject,\n  signal,\n  untracked,\n} from '@angular/core'\nimport { notifyManager, replaceEqualDeep } from '@tanstack/query-core'\nimport { assertInjector } from './util/assert-injector/assert-injector'\nimport { injectQueryClient } from './inject-query-client'\nimport { lazySignalInitializer } from './util/lazy-signal-initializer/lazy-signal-initializer'\nimport type { Injector, Signal } from '@angular/core'\nimport type {\n  Mutation,\n  MutationCache,\n  MutationFilters,\n  MutationState,\n} from '@tanstack/query-core'\n\ntype MutationStateOptions<TResult = MutationState> = {\n  filters?: MutationFilters\n  select?: (mutation: Mutation) => TResult\n}\n\nfunction getResult<TResult = MutationState>(\n  mutationCache: MutationCache,\n  options: MutationStateOptions<TResult>,\n): Array<TResult> {\n  return mutationCache\n    .findAll(options.filters)\n    .map(\n      (mutation): TResult =>\n        (options.select ? options.select(mutation) : mutation.state) as TResult,\n    )\n}\n\n/**\n * @public\n */\nexport interface InjectMutationStateOptions {\n  injector?: Injector\n}\n\n/**\n * Injects a signal that tracks the state of all mutations.\n * @param mutationStateOptionsFn - A function that returns mutation state options.\n * @param options - The Angular injector to use.\n * @returns The signal that tracks the state of all mutations.\n * @public\n */\nexport function injectMutationState<TResult = MutationState>(\n  mutationStateOptionsFn: () => MutationStateOptions<TResult> = () => ({}),\n  options?: InjectMutationStateOptions,\n): Signal<Array<TResult>> {\n  return assertInjector(injectMutationState, options?.injector, () => {\n    const destroyRef = inject(DestroyRef)\n    const queryClient = injectQueryClient()\n    const ngZone = inject(NgZone)\n\n    const mutationCache = queryClient.getMutationCache()\n\n    return lazySignalInitializer((injector) => {\n      const result = signal<Array<TResult>>(\n        getResult(mutationCache, mutationStateOptionsFn()),\n      )\n\n      effect(\n        () => {\n          const mutationStateOptions = mutationStateOptionsFn()\n          untracked(() => {\n            // Setting the signal from an effect because it's both 'computed' from options()\n            // and needs to be set imperatively in the mutationCache listener.\n            result.set(getResult(mutationCache, mutationStateOptions))\n          })\n        },\n        { injector },\n      )\n\n      const unsubscribe = mutationCache.subscribe(\n        notifyManager.batchCalls(() => {\n          const nextResult = replaceEqualDeep(\n            result(),\n            getResult(mutationCache, mutationStateOptionsFn()),\n          )\n          if (result() !== nextResult) {\n            ngZone.run(() => {\n              result.set(nextResult)\n            })\n          }\n        }),\n      )\n\n      destroyRef.onDestroy(unsubscribe)\n\n      return result\n    })\n  })\n}\n","import { QueriesObserver, notifyManager } from '@tanstack/query-core'\nimport { DestroyRef, computed, effect, inject, signal } from '@angular/core'\nimport { assertInjector } from './util/assert-injector/assert-injector'\nimport { injectQueryClient } from './inject-query-client'\nimport type { Injector, Signal } from '@angular/core'\nimport type {\n  DefaultError,\n  OmitKeyof,\n  QueriesObserverOptions,\n  QueriesPlaceholderDataFunction,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  QueryObserverResult,\n  ThrowOnError,\n} from '@tanstack/query-core'\n\n// This defines the `CreateQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// `placeholderData` function does not have a parameter\ntype QueryObserverOptionsForCreateQueries<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = OmitKeyof<\n  QueryObserverOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>,\n  'placeholderData'\n> & {\n  placeholderData?: TQueryFnData | QueriesPlaceholderDataFunction<TQueryFnData>\n}\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\n// Widen the type of the symbol to enable type inference even if skipToken is not immutable.\ntype SkipTokenForUseQueries = symbol\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? QueryObserverOptionsForCreateQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? QueryObserverOptionsForCreateQueries<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? QueryObserverOptionsForCreateQueries<unknown, TError, TData>\n        : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n          T extends [infer TQueryFnData, infer TError, infer TData]\n          ? QueryObserverOptionsForCreateQueries<TQueryFnData, TError, TData>\n          : T extends [infer TQueryFnData, infer TError]\n            ? QueryObserverOptionsForCreateQueries<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? QueryObserverOptionsForCreateQueries<TQueryFnData>\n              : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                      | SkipTokenForUseQueries\n                    select: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? QueryObserverOptionsForCreateQueries<\n                    TQueryFnData,\n                    unknown extends TError ? DefaultError : TError,\n                    unknown extends TData ? TQueryFnData : TData,\n                    TQueryKey\n                  >\n                : // Fallback\n                  QueryObserverOptionsForCreateQueries\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? QueryObserverResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? QueryObserverResult<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? QueryObserverResult<TData, TError>\n        : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n          T extends [any, infer TError, infer TData]\n          ? QueryObserverResult<TData, TError>\n          : T extends [infer TQueryFnData, infer TError]\n            ? QueryObserverResult<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? QueryObserverResult<TQueryFnData>\n              : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, any>\n                      | SkipTokenForUseQueries\n                    select: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? QueryObserverResult<\n                    unknown extends TData ? TQueryFnData : TData,\n                    unknown extends TError ? DefaultError : TError\n                  >\n                : // Fallback\n                  QueryObserverResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n * @public\n */\nexport type QueriesOptions<\n  T extends Array<any>,\n  TResult extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<QueryObserverOptionsForCreateQueries>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResult, GetOptions<Head>]\n      : T extends [infer Head, ...infer Tail]\n        ? QueriesOptions<\n            [...Tail],\n            [...TResult, GetOptions<Head>],\n            [...TDepth, 1]\n          >\n        : ReadonlyArray<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                QueryObserverOptionsForCreateQueries<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                QueryObserverOptionsForCreateQueries<\n                  TQueryFnData,\n                  TError,\n                  TData,\n                  TQueryKey\n                >\n              >\n            : // Fallback\n              Array<QueryObserverOptionsForCreateQueries>\n\n/**\n * QueriesResults reducer recursively maps type param to results\n * @public\n */\nexport type QueriesResults<\n  T extends Array<any>,\n  TResult extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<QueryObserverResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResult, GetResults<Head>]\n      : T extends [infer Head, ...infer Tail]\n        ? QueriesResults<\n            [...Tail],\n            [...TResult, GetResults<Head>],\n            [...TDepth, 1]\n          >\n        : T extends Array<\n              QueryObserverOptionsForCreateQueries<\n                infer TQueryFnData,\n                infer TError,\n                infer TData,\n                any\n              >\n            >\n          ? // Dynamic-size (homogenous) CreateQueryOptions array: map directly to array of results\n            Array<\n              QueryObserverResult<\n                unknown extends TData ? TQueryFnData : TData,\n                unknown extends TError ? DefaultError : TError\n              >\n            >\n          : // Fallback\n            Array<QueryObserverResult>\n\n/**\n * @public\n */\nexport function injectQueries<\n  T extends Array<any>,\n  TCombinedResult = QueriesResults<T>,\n>(\n  {\n    queries,\n    ...options\n  }: {\n    queries: Signal<[...QueriesOptions<T>]>\n    combine?: (result: QueriesResults<T>) => TCombinedResult\n  },\n  injector?: Injector,\n): Signal<TCombinedResult> {\n  return assertInjector(injectQueries, injector, () => {\n    const queryClient = injectQueryClient()\n    const destroyRef = inject(DestroyRef)\n\n    const defaultedQueries = computed(() => {\n      return queries().map((opts) => {\n        const defaultedOptions = queryClient.defaultQueryOptions(opts)\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = 'optimistic'\n\n        return defaultedOptions as QueryObserverOptions\n      })\n    })\n\n    const observer = new QueriesObserver<TCombinedResult>(\n      queryClient,\n      defaultedQueries(),\n      options as QueriesObserverOptions<TCombinedResult>,\n    )\n\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    effect(() => {\n      observer.setQueries(\n        defaultedQueries(),\n        options as QueriesObserverOptions<TCombinedResult>,\n        { listeners: false },\n      )\n    })\n\n    const [, getCombinedResult] = observer.getOptimisticResult(\n      defaultedQueries(),\n      (options as QueriesObserverOptions<TCombinedResult>).combine,\n    )\n\n    const result = signal(getCombinedResult() as any)\n\n    const unsubscribe = observer.subscribe(notifyManager.batchCalls(result.set))\n    destroyRef.onDestroy(unsubscribe)\n\n    return result\n  })\n}\n","import { QueryObserver } from '@tanstack/query-core'\nimport { assertInjector } from './util/assert-injector/assert-injector'\nimport { createBaseQuery } from './create-base-query'\nimport type { Injector } from '@angular/core'\nimport type { DefaultError, QueryClient, QueryKey } from '@tanstack/query-core'\nimport type {\n  CreateQueryOptions,\n  CreateQueryResult,\n  DefinedCreateQueryResult,\n} from './types'\nimport type {\n  DefinedInitialDataOptions,\n  UndefinedInitialDataOptions,\n} from './query-options'\n\n/**\n * Injects a query: a declarative dependency on an asynchronous source of data that is tied to a unique key.\n *\n * **Basic example**\n * ```ts\n * class ServiceOrComponent {\n *   query = injectQuery(() => ({\n *     queryKey: ['repoData'],\n *     queryFn: () =>\n *       this.#http.get<Response>('https://api.github.com/repos/tanstack/query'),\n *   }))\n * }\n * ```\n *\n * Similar to `computed` from Angular, the function passed to `injectQuery` will be run in the reactive context.\n * In the example below, the query will be automatically enabled and executed when the filter signal changes\n * to a truthy value. When the filter signal changes back to a falsy value, the query will be disabled.\n *\n * **Reactive example**\n * ```ts\n * class ServiceOrComponent {\n *   filter = signal('')\n *\n *   todosQuery = injectQuery(() => ({\n *     queryKey: ['todos', this.filter()],\n *     queryFn: () => fetchTodos(this.filter()),\n *     // Signals can be combined with expressions\n *     enabled: !!this.filter(),\n *   }))\n * }\n * ```\n * @param optionsFn - A function that returns query options.\n * @param injector - The Angular injector to use.\n * @returns The query result.\n * @public\n * @see https://tanstack.com/query/latest/docs/framework/angular/guides/queries\n */\nexport function injectQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  optionsFn: (\n    client: QueryClient,\n  ) => DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  injector?: Injector,\n): DefinedCreateQueryResult<TData, TError>\n\n/**\n * Injects a query: a declarative dependency on an asynchronous source of data that is tied to a unique key.\n *\n * **Basic example**\n * ```ts\n * class ServiceOrComponent {\n *   query = injectQuery(() => ({\n *     queryKey: ['repoData'],\n *     queryFn: () =>\n *       this.#http.get<Response>('https://api.github.com/repos/tanstack/query'),\n *   }))\n * }\n * ```\n *\n * Similar to `computed` from Angular, the function passed to `injectQuery` will be run in the reactive context.\n * In the example below, the query will be automatically enabled and executed when the filter signal changes\n * to a truthy value. When the filter signal changes back to a falsy value, the query will be disabled.\n *\n * **Reactive example**\n * ```ts\n * class ServiceOrComponent {\n *   filter = signal('')\n *\n *   todosQuery = injectQuery(() => ({\n *     queryKey: ['todos', this.filter()],\n *     queryFn: () => fetchTodos(this.filter()),\n *     // Signals can be combined with expressions\n *     enabled: !!this.filter(),\n *   }))\n * }\n * ```\n * @param optionsFn - A function that returns query options.\n * @param injector - The Angular injector to use.\n * @returns The query result.\n * @public\n * @see https://tanstack.com/query/latest/docs/framework/angular/guides/queries\n */\nexport function injectQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  optionsFn: (\n    client: QueryClient,\n  ) => UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  injector?: Injector,\n): CreateQueryResult<TData, TError>\n\n/**\n * Injects a query: a declarative dependency on an asynchronous source of data that is tied to a unique key.\n *\n * **Basic example**\n * ```ts\n * class ServiceOrComponent {\n *   query = injectQuery(() => ({\n *     queryKey: ['repoData'],\n *     queryFn: () =>\n *       this.#http.get<Response>('https://api.github.com/repos/tanstack/query'),\n *   }))\n * }\n * ```\n *\n * Similar to `computed` from Angular, the function passed to `injectQuery` will be run in the reactive context.\n * In the example below, the query will be automatically enabled and executed when the filter signal changes\n * to a truthy value. When the filter signal changes back to a falsy value, the query will be disabled.\n *\n * **Reactive example**\n * ```ts\n * class ServiceOrComponent {\n *   filter = signal('')\n *\n *   todosQuery = injectQuery(() => ({\n *     queryKey: ['todos', this.filter()],\n *     queryFn: () => fetchTodos(this.filter()),\n *     // Signals can be combined with expressions\n *     enabled: !!this.filter(),\n *   }))\n * }\n * ```\n * @param optionsFn - A function that returns query options.\n * @param injector - The Angular injector to use.\n * @returns The query result.\n * @public\n * @see https://tanstack.com/query/latest/docs/framework/angular/guides/queries\n */\nexport function injectQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  optionsFn: (\n    client: QueryClient,\n  ) => CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  injector?: Injector,\n): CreateQueryResult<TData, TError>\n\n/**\n * Injects a query: a declarative dependency on an asynchronous source of data that is tied to a unique key.\n *\n * **Basic example**\n * ```ts\n * class ServiceOrComponent {\n *   query = injectQuery(() => ({\n *     queryKey: ['repoData'],\n *     queryFn: () =>\n *       this.#http.get<Response>('https://api.github.com/repos/tanstack/query'),\n *   }))\n * }\n * ```\n *\n * Similar to `computed` from Angular, the function passed to `injectQuery` will be run in the reactive context.\n * In the example below, the query will be automatically enabled and executed when the filter signal changes\n * to a truthy value. When the filter signal changes back to a falsy value, the query will be disabled.\n *\n * **Reactive example**\n * ```ts\n * class ServiceOrComponent {\n *   filter = signal('')\n *\n *   todosQuery = injectQuery(() => ({\n *     queryKey: ['todos', this.filter()],\n *     queryFn: () => fetchTodos(this.filter()),\n *     // Signals can be combined with expressions\n *     enabled: !!this.filter(),\n *   }))\n * }\n * ```\n * @param optionsFn - A function that returns query options.\n * @param injector - The Angular injector to use.\n * @returns The query result.\n * @public\n * @see https://tanstack.com/query/latest/docs/framework/angular/guides/queries\n */\nexport function injectQuery(\n  optionsFn: (client: QueryClient) => CreateQueryOptions,\n  injector?: Injector,\n) {\n  return assertInjector(injectQuery, injector, () =>\n    createBaseQuery(optionsFn, QueryObserver),\n  )\n}\n","import {\n  DestroyRef,\n  ENVIRONMENT_INITIALIZER,\n  inject,\n  makeEnvironmentProviders,\n} from '@angular/core'\nimport { provideQueryClient } from './inject-query-client'\nimport type { EnvironmentProviders } from '@angular/core'\nimport type { QueryClient } from '@tanstack/query-core'\n\n/**\n * Sets up providers necessary to enable TanStack Query functionality for Angular applications.\n *\n * Allows to configure a `QueryClient`.\n *\n * **Example - standalone**\n *\n * ```ts\n * import {\n *   provideAngularQuery,\n *   QueryClient,\n * } from '@tanstack/angular-query-experimental'\n *\n * bootstrapApplication(AppComponent, {\n *   providers: [provideAngularQuery(new QueryClient())],\n * })\n * ```\n *\n * **Example - NgModule-based**\n *\n * ```ts\n * import {\n *   provideAngularQuery,\n *   QueryClient,\n * } from '@tanstack/angular-query-experimental'\n *\n * @NgModule({\n *   declarations: [AppComponent],\n *   imports: [BrowserModule],\n *   providers: [provideAngularQuery(new QueryClient())],\n *   bootstrap: [AppComponent],\n * })\n * export class AppModule {}\n * ```\n * @param queryClient - A `QueryClient` instance.\n * @returns A set of providers to set up TanStack Query.\n * @public\n * @see https://tanstack.com/query/v5/docs/framework/angular/quick-start\n */\nexport function provideAngularQuery(\n  queryClient: QueryClient,\n): EnvironmentProviders {\n  return makeEnvironmentProviders([\n    provideQueryClient(queryClient),\n    {\n      provide: ENVIRONMENT_INITIALIZER,\n      multi: true,\n      useValue: () => {\n        queryClient.mount()\n        // Unmount the query client on application destroy\n        inject(DestroyRef).onDestroy(() => queryClient.unmount())\n      },\n    },\n  ])\n}\n","/* istanbul ignore file */\n\n// Re-export core\nexport * from '@tanstack/query-core'\n\nexport * from './types'\n\nexport type {\n  DefinedInitialDataOptions,\n  UndefinedInitialDataOptions,\n} from './query-options'\nexport { queryOptions } from './query-options'\n\nexport type {\n  DefinedInitialDataInfiniteOptions,\n  UndefinedInitialDataInfiniteOptions,\n} from './infinite-query-options'\nexport { infiniteQueryOptions } from './infinite-query-options'\n\nexport * from './inject-infinite-query'\nexport * from './inject-is-fetching'\nexport * from './inject-is-mutating'\nexport * from './inject-mutation'\nexport * from './inject-mutation-state'\nexport * from './inject-queries'\nexport * from './inject-query'\nexport { injectQueryClient, provideQueryClient } from './inject-query-client'\nexport { provideAngularQuery } from './providers'\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":";;;;AAAA;;ACoGA;;;;;;;;;;;;;;;;;;;;;AAqBG;AACG,SAAU,YAAY,CAAC,OAAgB,EAAA;AAC3C,IAAA,OAAO,OAAO,CAAA;AAChB;;ACVA;;;;;;;AAOG;AACG,SAAU,oBAAoB,CAAC,OAAgB,EAAA;AACnD,IAAA,OAAO,OAAO,CAAA;AAChB;;ACrHA;;;;;AAKG;AACG,SAAU,WAAW,CACzB,WAA2B,EAAA;IAE3B,MAAM,aAAa,GAAG,EAA0B,CAAA;AAEhD,IAAA,OAAO,IAAI,KAAK,CAAuB,aAAa,EAAE;QACpD,GAAG,CAAC,MAAM,EAAE,IAAI,EAAA;;AAEd,YAAA,MAAM,aAAa,GAAG,MAAM,CAAC,IAAI,CAAC,CAAA;AAClC,YAAA,IAAI,aAAa;AAAE,gBAAA,OAAO,aAAa,CAAA;;YAGvC,MAAM,WAAW,GAAG,SAAS,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,CAAA;YAChD,IAAI,OAAO,WAAW,KAAK,UAAU;AAAE,gBAAA,OAAO,WAAW,CAAA;;;AAIzD,YAAA,QAAQ,MAAM,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,MAAM,WAAW,EAAE,CAAC,IAAI,CAAC,CAAC,EAAC;SAC5D;QACD,GAAG,CAAC,CAAC,EAAE,IAAI,EAAA;YACT,OAAO,CAAC,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,CAAA;SACtC;QACD,OAAO,GAAA;YACL,OAAO,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC,CAAA;SAC/C;QACD,wBAAwB,GAAA;YACtB,OAAO;AACL,gBAAA,UAAU,EAAE,IAAI;AAChB,gBAAA,YAAY,EAAE,IAAI;aACnB,CAAA;SACF;AACF,KAAA,CAAC,CAAA;AACJ;;AC7CgB,SAAA,gBAAgB,CAC9B,UAAmC,EACnC,MAAqB,EAAA;;AAGrB,IAAA,IAAI,OAAO,UAAU,KAAK,UAAU,EAAE;AACpC,QAAA,OAAO,UAAU,CAAC,GAAG,MAAM,CAAC,CAAA;KAC7B;IAED,OAAO,CAAC,CAAC,UAAU,CAAA;AACrB,CAAC;AAEK,SAAU,IAAI,GAAA;;ACVd,SAAU,QAAQ,CAAmB,WAAoB,EAAA;IAC7D,IAAI,MAAM,GAAa,IAAI,CAAA;IAE3B,MAAM,gBAAgB,GAAG,MAAK;QAC5B,IAAI,CAAC,MAAM,EAAE;YACX,MAAM,GAAG,SAAS,CAAC,MAAM,WAAW,EAAE,CAAC,CAAA;SACxC;AACH,KAAC,CAAA;AAED,IAAA,cAAc,CAAC,MAAM,gBAAgB,EAAE,CAAC,CAAA;AAExC,IAAA,OAAO,IAAI,KAAK,CAAI,EAAO,EAAE;AAC3B,QAAA,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAA;AACnB,YAAA,gBAAgB,EAAE,CAAA;YAClB,OAAO,OAAO,CAAC,GAAG,CAAC,MAAW,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAA;SAChD;QACD,GAAG,CAAC,CAAC,EAAE,IAAI,EAAA;AACT,YAAA,gBAAgB,EAAE,CAAA;YAClB,OAAO,OAAO,CAAC,GAAG,CAAC,MAAW,EAAE,IAAI,CAAC,CAAA;SACtC;QACD,OAAO,GAAA;AACL,YAAA,gBAAgB,EAAE,CAAA;AAClB,YAAA,OAAO,OAAO,CAAC,OAAO,CAAC,MAAW,CAAC,CAAA;SACpC;QACD,wBAAwB,GAAA;YACtB,OAAO;AACL,gBAAA,UAAU,EAAE,IAAI;AAChB,gBAAA,YAAY,EAAE,IAAI;aACnB,CAAA;SACF;AACF,KAAA,CAAC,CAAA;AACJ;;ACjCA;AACA;;;;;;;;;AASG;AACH;SA2DgB,cAAc,CAC5B,EAAY,EACZ,QAAqC,EACrC,MAAkB,EAAA;AAElB,IAAA,CAAC,QAAQ,IAAI,wBAAwB,CAAC,EAAE,CAAC,CAAA;IACzC,MAAM,gBAAgB,GAAG,QAAQ,IAAI,MAAM,CAAC,QAAQ,CAAC,CAAA;AAErD,IAAA,IAAI,CAAC,MAAM;AAAE,QAAA,OAAO,gBAAgB,CAAA;AACpC,IAAA,OAAO,qBAAqB,CAAC,gBAAgB,EAAE,MAAM,CAAC,CAAA;AACxD;;AChFA;AACA;;;;;;;;;AASG;AACH;AA0FA,SAAS,cAAc,CAAS,KAA6B,EAAA;AAC3D,IAAA,OAAO,UAEL,EACE,QAAQ,EACR,GAAG,aAAa,KAC2B,EAAE,EAAA;AAE/C,QAAA,QAAQ,GAAG,cAAc,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAA;AACzC,QAAA,OAAO,qBAAqB,CAAC,QAAQ,EAAE,MACrC,MAAM,CAAC,KAAK,EAAE,aAA8B,CAAC,CAC9C,CAAA;AACH,KAAC,CAAA;AACH,CAAC;AAED,SAAS,eAAe,CAOtB,KAA6B,EAC7B,OAAwC,EACxC,OAAuD,EAAE,EAAA;AAEzD,IAAA,MAAM,EAAE,IAAI,GAAG,EAAE,EAAE,KAAK,GAAG,KAAK,EAAE,cAAc,GAAG,EAAE,EAAE,GAAG,IAAI,CAAA;AAC9D,IAAA,OAAO,CAAC,KAA+B,EAAE,eAAe,GAAG,KAAK,KAAI;AAClE,QAAA,IAAI,QAAkB,CAAA;AACtB,QAAA,IAAI,KAAK,KAAK,SAAS,EAAE;;AAEvB,YAAA,MAAM,OAAO,GACX,OAAO,KAAK,KAAK,UAAU;AACzB,kBAAE,eAAe;AACf,sBAAE,MAAM,KAAK;AACb,sBAAE,KAAK;AACT,kBAAE,MAAM,KAAK,CAAA;AAEjB,YAAA,QAAQ,GAAG;AACT,gBAAA,OAAO,EAAE,KAAK;AACd,gBAAA,UAAU,EAAE,OAAO;gBACnB,KAAK;aACN,CAAA;SACF;aAAM;AACL,YAAA,QAAQ,GAAG;AACT,gBAAA,OAAO,EAAE,KAAK;AACd,gBAAA,UAAU,EAAE,OAAO;AACnB,gBAAA,IAAI,EAAE,IAA+B;gBACrC,KAAK;aACN,CAAA;SACF;AAED,QAAA,OAAO,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAA;AACnC,KAAC,CAAA;AACH,CAAC;AAEe,SAAA,wBAAwB,CAQtC,WAAmB,EAAE,OAAkB,EAAA;AAGvC,IAAA,MAAM,KAAK;;AAER,IAAA,OAAuD,EAAE,KAAK;AAC/D,QAAA,IAAI,cAAc,CAAU,WAAW,CAAC,CAAA;IAC1C,OAAO;QACL,cAAc,CAAC,KAAK,CAAiD;AACrE,QAAA,eAAe,CACb,KAAK,EACL,MAAM,IAAK,GACV,OAAO,IAAI,EAAE,EACiC;QACjD,KAAK;QACL,SAAQ;KACoC,CAAA;AAChD;;ACnLA,MAAM,MAAM,GAAG,wBAAwB,CAAc,kBAAkB,CAAC,CAAA;AAExE;;;;;;;;;AASG;MACU,iBAAiB,GAAG,MAAM,CAAC,CAAC,EAAC;AAE1C;;;;;;AAMG;MACU,kBAAkB,GAAG,MAAM,CAAC,CAAC;;ACA1C;;AAEG;AACa,SAAA,eAAe,CAO7B,SAQC,EACD,QAA8B,EAAA;AAE9B,IAAA,MAAM,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAA;IACjC,OAAO,QAAQ,CAAC,MAAK;QACnB,MAAM,MAAM,GAAG,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;QACnC,MAAM,UAAU,GAAG,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAC,CAAA;QAC3C,MAAM,WAAW,GAAG,iBAAiB,CAAC,EAAE,QAAQ,EAAE,CAAC,CAAA;AAEnD;;;;;AAKG;AACH,QAAA,MAAM,sBAAsB,GAAG,QAAQ,CAAC,MAAK;AAC3C,YAAA,MAAM,OAAO,GAAG,qBAAqB,CAAC,QAAQ,EAAE,MAC9C,SAAS,CAAC,WAAW,CAAC,CACvB,CAAA;YACD,MAAM,gBAAgB,GAAG,WAAW,CAAC,mBAAmB,CAAC,OAAO,CAAC,CAAA;AACjE,YAAA,gBAAgB,CAAC,kBAAkB,GAAG,YAAY,CAAA;AAClD,YAAA,OAAO,gBAAgB,CAAA;AACzB,SAAC,CAAC,CAAA;QAEF,MAAM,QAAQ,GAAG,IAAI,QAAQ,CAM3B,WAAW,EAAE,sBAAsB,EAAE,CAAC,CAAA;AAExC,QAAA,MAAM,YAAY,GAAG,MAAM,CACzB,QAAQ,CAAC,mBAAmB,CAAC,sBAAsB,EAAE,CAAC,CACvD,CAAA;QAED,MAAM,CACJ,MAAK;AACH,YAAA,MAAM,gBAAgB,GAAG,sBAAsB,EAAE,CAAA;AACjD,YAAA,QAAQ,CAAC,UAAU,CAAC,gBAAgB,EAAE;;;AAGpC,gBAAA,SAAS,EAAE,KAAK;AACjB,aAAA,CAAC,CAAA;YACF,SAAS,CAAC,MAAK;gBACb,YAAY,CAAC,GAAG,CAAC,QAAQ,CAAC,mBAAmB,CAAC,gBAAgB,CAAC,CAAC,CAAA;AAClE,aAAC,CAAC,CAAA;AACJ,SAAC,EACD;YACE,QAAQ;AACT,SAAA,CACF,CAAA;;AAGD,QAAA,MAAM,WAAW,GAAG,QAAQ,CAAC,SAAS,CACpC,aAAa,CAAC,UAAU,CAAC,CAAC,KAAyC,KAAI;AACrE,YAAA,MAAM,CAAC,GAAG,CAAC,MAAK;gBACd,IACE,KAAK,CAAC,OAAO;oBACb,CAAC,KAAK,CAAC,UAAU;;AAEjB,oBAAA,gBAAgB,CAAC,QAAQ,CAAC,OAAO,CAAC,YAAY,EAAE;AAC9C,wBAAA,KAAK,CAAC,KAAK;wBACX,QAAQ,CAAC,eAAe,EAAE;AAC3B,qBAAA,CAAC,EACF;oBACA,MAAM,KAAK,CAAC,KAAK,CAAA;iBAClB;AACD,gBAAA,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;AACzB,aAAC,CAAC,CAAA;SACH,CAAC,CACH,CAAA;AACD,QAAA,UAAU,CAAC,SAAS,CAAC,WAAW,CAAC,CAAA;AAEjC,QAAA,OAAO,WAAW,CAAC,YAAY,CAAyC,CAAA;AAC1E,KAAC,CAAC,CAAA;AACJ;;ACfA;;;;;;;AAOG;AACa,SAAA,mBAAmB,CACjC,SAA8D,EAC9D,QAAmB,EAAA;AAEnB,IAAA,OAAO,cAAc,CAAC,mBAAmB,EAAE,QAAQ,EAAE,MACnD,eAAe,CAAC,SAAS,EAAE,qBAA6C,CAAC,CAC1E,CAAA;AACH;;AC/GA;;;;;;;;;AASG;AACa,SAAA,gBAAgB,CAC9B,OAAsB,EACtB,QAAmB,EAAA;AAEnB,IAAA,OAAO,cAAc,CAAC,gBAAgB,EAAE,QAAQ,EAAE,MAAK;AACrD,QAAA,MAAM,WAAW,GAAG,iBAAiB,EAAE,CAAA;AACvC,QAAA,MAAM,UAAU,GAAG,MAAM,CAAC,UAAU,CAAC,CAAA;AACrC,QAAA,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,CAAA;AAE7B,QAAA,MAAM,KAAK,GAAG,WAAW,CAAC,aAAa,EAAE,CAAA;;QAEzC,IAAI,UAAU,GAAG,WAAW,CAAC,UAAU,CAAC,OAAO,CAAC,CAAA;AAEhD,QAAA,MAAM,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC,CAAA;QAEjC,MAAM,WAAW,GAAG,KAAK,CAAC,SAAS,CACjC,aAAa,CAAC,UAAU,CAAC,MAAK;YAC5B,MAAM,aAAa,GAAG,WAAW,CAAC,UAAU,CAAC,OAAO,CAAC,CAAA;AACrD,YAAA,IAAI,UAAU,KAAK,aAAa,EAAE;;gBAEhC,UAAU,GAAG,aAAa,CAAA;AAC1B,gBAAA,MAAM,CAAC,GAAG,CAAC,MAAK;AACd,oBAAA,MAAM,CAAC,GAAG,CAAC,UAAU,CAAC,CAAA;AACxB,iBAAC,CAAC,CAAA;aACH;SACF,CAAC,CACH,CAAA;AAED,QAAA,UAAU,CAAC,SAAS,CAAC,WAAW,CAAC,CAAA;AAEjC,QAAA,OAAO,MAAM,CAAA;AACf,KAAC,CAAC,CAAA;AACJ;;AC1CA;;;;;;;;AAQG;AACa,SAAA,gBAAgB,CAC9B,OAAyB,EACzB,QAAmB,EAAA;AAEnB,IAAA,OAAO,cAAc,CAAC,gBAAgB,EAAE,QAAQ,EAAE,MAAK;AACrD,QAAA,MAAM,WAAW,GAAG,iBAAiB,EAAE,CAAA;AACvC,QAAA,MAAM,UAAU,GAAG,MAAM,CAAC,UAAU,CAAC,CAAA;AACrC,QAAA,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,CAAA;AAE7B,QAAA,MAAM,KAAK,GAAG,WAAW,CAAC,gBAAgB,EAAE,CAAA;;QAE5C,IAAI,UAAU,GAAG,WAAW,CAAC,UAAU,CAAC,OAAO,CAAC,CAAA;AAEhD,QAAA,MAAM,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC,CAAA;QAEjC,MAAM,WAAW,GAAG,KAAK,CAAC,SAAS,CACjC,aAAa,CAAC,UAAU,CAAC,MAAK;YAC5B,MAAM,aAAa,GAAG,WAAW,CAAC,UAAU,CAAC,OAAO,CAAC,CAAA;AACrD,YAAA,IAAI,UAAU,KAAK,aAAa,EAAE;;gBAEhC,UAAU,GAAG,aAAa,CAAA;AAC1B,gBAAA,MAAM,CAAC,GAAG,CAAC,MAAK;AACd,oBAAA,MAAM,CAAC,GAAG,CAAC,UAAU,CAAC,CAAA;AACxB,iBAAC,CAAC,CAAA;aACH;SACF,CAAC,CACH,CAAA;AAED,QAAA,UAAU,CAAC,SAAS,CAAC,WAAW,CAAC,CAAA;AAEjC,QAAA,OAAO,MAAM,CAAA;AACf,KAAC,CAAC,CAAA;AACJ;;ACpBA;;;;;;;;AAQG;AACa,SAAA,cAAc,CAM5B,SAE+D,EAC/D,QAAmB,EAAA;AAEnB,IAAA,OAAO,cAAc,CAAC,cAAc,EAAE,QAAQ,EAAE,MAAK;AACnD,QAAA,MAAM,WAAW,GAAG,iBAAiB,EAAE,CAAA;AACvC,QAAA,MAAM,eAAe,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAA;AACxC,QAAA,MAAM,UAAU,GAAG,MAAM,CAAC,UAAU,CAAC,CAAA;AACrC,QAAA,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,CAAA;QAE7B,OAAO,QAAQ,CAAC,MACd,qBAAqB,CAAC,eAAe,EAAE,MAAK;AAC1C,YAAA,MAAM,QAAQ,GAAG,IAAI,gBAAgB,CAKnC,WAAW,EAAE,SAAS,CAAC,WAAW,CAAC,CAAC,CAAA;AACtC,YAAA,MAAM,MAAM,GAKR,CAAC,SAAS,EAAE,aAAa,KAAI;AAC/B,gBAAA,QAAQ,CAAC,MAAM,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAA;AACvD,aAAC,CAAA;YAED,MAAM,CAAC,MAAK;AACV,gBAAA,QAAQ,CAAC,UAAU,CACjB,qBAAqB,CAAC,eAAe,EAAE,MACrC,SAAS,CAAC,WAAW,CAAC,CACvB,CACF,CAAA;AACH,aAAC,CAAC,CAAA;YAEF,MAAM,MAAM,GAAG,MAAM,CAAC,QAAQ,CAAC,gBAAgB,EAAE,CAAC,CAAA;AAElD,YAAA,MAAM,WAAW,GAAG,QAAQ,CAAC,SAAS,CACpC,aAAa,CAAC,UAAU,CACtB,CACE,KAKC,KACC;AACF,gBAAA,MAAM,CAAC,GAAG,CAAC,MAAK;oBACd,IACE,KAAK,CAAC,OAAO;AACb,wBAAA,gBAAgB,CAAC,QAAQ,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAC9D;wBACA,MAAM,KAAK,CAAC,KAAK,CAAA;qBAClB;AACD,oBAAA,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;AACnB,iBAAC,CAAC,CAAA;aACH,CACF,CACF,CAAA;AAED,YAAA,UAAU,CAAC,SAAS,CAAC,WAAW,CAAC,CAAA;AAEjC,YAAA,MAAM,YAAY,GAAG,QAAQ,CAAC,OAAO;AACnC,gBAAA,GAAG,MAAM,EAAE;gBACX,MAAM;AACN,gBAAA,WAAW,EAAE,MAAM,EAAE,CAAC,MAAM;AAC7B,aAAA,CAAC,CAAC,CAAA;AAEH,YAAA,OAAO,WAAW,CAAC,YAAY,CAK9B,CAAA;SACF,CAAC,CACH,CAAA;AACH,KAAC,CAAC,CAAA;AACJ;;ACpHM,SAAU,qBAAqB,CACnC,aAAqC,EAAA;AAErC,IAAA,MAAM,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAA;IAEjC,IAAI,MAAM,GAAqB,IAAI,CAAA;IAEnC,MAAM,YAAY,GAAG,MAAK;QACxB,IAAI,CAAC,MAAM,EAAE;YACX,MAAM,GAAG,SAAS,CAAC,MAAM,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAA;SAClD;QACD,OAAO,MAAM,EAAE,CAAA;AACjB,KAAC,CAAA;AAED,IAAA,cAAc,CAAC,MAAM,YAAY,EAAE,CAAC,CAAA;AAEpC,IAAA,OAAO,QAAQ,CAAC,YAAY,CAAC,CAAA;AAC/B;;ACGA,SAAS,SAAS,CAChB,aAA4B,EAC5B,OAAsC,EAAA;AAEtC,IAAA,OAAO,aAAa;AACjB,SAAA,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC;SACxB,GAAG,CACF,CAAC,QAAQ,MACN,OAAO,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,QAAQ,CAAC,KAAK,CAAY,CAC1E,CAAA;AACL,CAAC;AASD;;;;;;AAMG;AACG,SAAU,mBAAmB,CACjC,sBAA8D,GAAA,OAAO,EAAE,CAAC,EACxE,OAAoC,EAAA;IAEpC,OAAO,cAAc,CAAC,mBAAmB,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAK;AACjE,QAAA,MAAM,UAAU,GAAG,MAAM,CAAC,UAAU,CAAC,CAAA;AACrC,QAAA,MAAM,WAAW,GAAG,iBAAiB,EAAE,CAAA;AACvC,QAAA,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,CAAA;AAE7B,QAAA,MAAM,aAAa,GAAG,WAAW,CAAC,gBAAgB,EAAE,CAAA;AAEpD,QAAA,OAAO,qBAAqB,CAAC,CAAC,QAAQ,KAAI;AACxC,YAAA,MAAM,MAAM,GAAG,MAAM,CACnB,SAAS,CAAC,aAAa,EAAE,sBAAsB,EAAE,CAAC,CACnD,CAAA;YAED,MAAM,CACJ,MAAK;AACH,gBAAA,MAAM,oBAAoB,GAAG,sBAAsB,EAAE,CAAA;gBACrD,SAAS,CAAC,MAAK;;;oBAGb,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,aAAa,EAAE,oBAAoB,CAAC,CAAC,CAAA;AAC5D,iBAAC,CAAC,CAAA;AACJ,aAAC,EACD,EAAE,QAAQ,EAAE,CACb,CAAA;YAED,MAAM,WAAW,GAAG,aAAa,CAAC,SAAS,CACzC,aAAa,CAAC,UAAU,CAAC,MAAK;AAC5B,gBAAA,MAAM,UAAU,GAAG,gBAAgB,CACjC,MAAM,EAAE,EACR,SAAS,CAAC,aAAa,EAAE,sBAAsB,EAAE,CAAC,CACnD,CAAA;AACD,gBAAA,IAAI,MAAM,EAAE,KAAK,UAAU,EAAE;AAC3B,oBAAA,MAAM,CAAC,GAAG,CAAC,MAAK;AACd,wBAAA,MAAM,CAAC,GAAG,CAAC,UAAU,CAAC,CAAA;AACxB,qBAAC,CAAC,CAAA;iBACH;aACF,CAAC,CACH,CAAA;AAED,YAAA,UAAU,CAAC,SAAS,CAAC,WAAW,CAAC,CAAA;AAEjC,YAAA,OAAO,MAAM,CAAA;AACf,SAAC,CAAC,CAAA;AACJ,KAAC,CAAC,CAAA;AACJ;;ACsFA;;AAEG;AACG,SAAU,aAAa,CAI3B,EACE,OAAO,EACP,GAAG,OAAO,EAIX,EACD,QAAmB,EAAA;AAEnB,IAAA,OAAO,cAAc,CAAC,aAAa,EAAE,QAAQ,EAAE,MAAK;AAClD,QAAA,MAAM,WAAW,GAAG,iBAAiB,EAAE,CAAA;AACvC,QAAA,MAAM,UAAU,GAAG,MAAM,CAAC,UAAU,CAAC,CAAA;AAErC,QAAA,MAAM,gBAAgB,GAAG,QAAQ,CAAC,MAAK;YACrC,OAAO,OAAO,EAAE,CAAC,GAAG,CAAC,CAAC,IAAI,KAAI;gBAC5B,MAAM,gBAAgB,GAAG,WAAW,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAA;;AAE9D,gBAAA,gBAAgB,CAAC,kBAAkB,GAAG,YAAY,CAAA;AAElD,gBAAA,OAAO,gBAAwC,CAAA;AACjD,aAAC,CAAC,CAAA;AACJ,SAAC,CAAC,CAAA;AAEF,QAAA,MAAM,QAAQ,GAAG,IAAI,eAAe,CAClC,WAAW,EACX,gBAAgB,EAAE,EAClB,OAAkD,CACnD,CAAA;;;QAID,MAAM,CAAC,MAAK;AACV,YAAA,QAAQ,CAAC,UAAU,CACjB,gBAAgB,EAAE,EAClB,OAAkD,EAClD,EAAE,SAAS,EAAE,KAAK,EAAE,CACrB,CAAA;AACH,SAAC,CAAC,CAAA;AAEF,QAAA,MAAM,GAAG,iBAAiB,CAAC,GAAG,QAAQ,CAAC,mBAAmB,CACxD,gBAAgB,EAAE,EACjB,OAAmD,CAAC,OAAO,CAC7D,CAAA;AAED,QAAA,MAAM,MAAM,GAAG,MAAM,CAAC,iBAAiB,EAAS,CAAC,CAAA;AAEjD,QAAA,MAAM,WAAW,GAAG,QAAQ,CAAC,SAAS,CAAC,aAAa,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAA;AAC5E,QAAA,UAAU,CAAC,SAAS,CAAC,WAAW,CAAC,CAAA;AAEjC,QAAA,OAAO,MAAM,CAAA;AACf,KAAC,CAAC,CAAA;AACJ;;AChFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCG;AACa,SAAA,WAAW,CACzB,SAAsD,EACtD,QAAmB,EAAA;AAEnB,IAAA,OAAO,cAAc,CAAC,WAAW,EAAE,QAAQ,EAAE,MAC3C,eAAe,CAAC,SAAS,EAAE,aAAa,CAAC,CAC1C,CAAA;AACH;;ACpMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCG;AACG,SAAU,mBAAmB,CACjC,WAAwB,EAAA;AAExB,IAAA,OAAO,wBAAwB,CAAC;QAC9B,kBAAkB,CAAC,WAAW,CAAC;AAC/B,QAAA;AACE,YAAA,OAAO,EAAE,uBAAuB;AAChC,YAAA,KAAK,EAAE,IAAI;YACX,QAAQ,EAAE,MAAK;gBACb,WAAW,CAAC,KAAK,EAAE,CAAA;;AAEnB,gBAAA,MAAM,CAAC,UAAU,CAAC,CAAC,SAAS,CAAC,MAAM,WAAW,CAAC,OAAO,EAAE,CAAC,CAAA;aAC1D;AACF,SAAA;AACF,KAAA,CAAC,CAAA;AACJ;;AChEA;AAEA;;ACFA;;AAEG;;;;"}