import type { DataTag } from '@tanstack/query-core';
import type { DefaultError } from '@tanstack/query-core';
import type { DefinedInfiniteQueryObserverResult } from '@tanstack/query-core';
import type { DefinedQueryObserverResult } from '@tanstack/query-core';
import type { EnvironmentProviders } from '@angular/core';
import type { InfiniteData } from '@tanstack/query-core';
import type { InfiniteQueryObserverOptions } from '@tanstack/query-core';
import type { InfiniteQueryObserverResult } from '@tanstack/query-core';
import type { InitialDataFunction } from '@tanstack/query-core';
import { InjectOptions } from '@angular/core';
import { Injector } from '@angular/core';
import type { MutateFunction } from '@tanstack/query-core';
import type { Mutation } from '@tanstack/query-core';
import type { MutationFilters } from '@tanstack/query-core';
import type { MutationObserverOptions } from '@tanstack/query-core';
import type { MutationObserverResult } from '@tanstack/query-core';
import type { MutationState } from '@tanstack/query-core';
import type { OmitKeyof } from '@tanstack/query-core';
import type { Override } from '@tanstack/query-core';
import { Provider } from '@angular/core';
import type { QueriesPlaceholderDataFunction } from '@tanstack/query-core';
import type { QueryClient } from '@tanstack/query-core';
import type { QueryFilters } from '@tanstack/query-core';
import type { QueryFunction } from '@tanstack/query-core';
import type { QueryKey } from '@tanstack/query-core';
import type { QueryObserverOptions } from '@tanstack/query-core';
import type { QueryObserverResult } from '@tanstack/query-core';
import type { Signal } from '@angular/core';
import type { ThrowOnError } from '@tanstack/query-core';

/**
 * @public
 */
export declare interface BaseMutationNarrowing<TData = unknown, TError = DefaultError, TVariables = unknown, TContext = unknown> {
    isSuccess: SignalFunction<(this: CreateMutationResult<TData, TError, TVariables, TContext>) => this is CreateMutationResult<TData, TError, TVariables, TContext, CreateStatusBasedMutationResult<'success', TData, TError, TVariables, TContext>>>;
    isError: SignalFunction<(this: CreateMutationResult<TData, TError, TVariables, TContext>) => this is CreateMutationResult<TData, TError, TVariables, TContext, CreateStatusBasedMutationResult<'error', TData, TError, TVariables, TContext>>>;
    isPending: SignalFunction<(this: CreateMutationResult<TData, TError, TVariables, TContext>) => this is CreateMutationResult<TData, TError, TVariables, TContext, CreateStatusBasedMutationResult<'pending', TData, TError, TVariables, TContext>>>;
    isIdle: SignalFunction<(this: CreateMutationResult<TData, TError, TVariables, TContext>) => this is CreateMutationResult<TData, TError, TVariables, TContext, CreateStatusBasedMutationResult<'idle', TData, TError, TVariables, TContext>>>;
}

/**
 * @public
 */
export declare interface BaseQueryNarrowing<TData = unknown, TError = DefaultError> {
    isSuccess: (this: CreateBaseQueryResult<TData, TError>) => this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<'success', TData, TError>>;
    isError: (this: CreateBaseQueryResult<TData, TError>) => this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<'error', TData, TError>>;
    isPending: (this: CreateBaseQueryResult<TData, TError>) => this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<'pending', TData, TError>>;
}

/**
 * @public
 */
export declare type CreateBaseMutationResult<TData = unknown, TError = DefaultError, TVariables = unknown, TContext = unknown> = Override<MutationObserverResult<TData, TError, TVariables, TContext>, {
    mutate: CreateMutateFunction<TData, TError, TVariables, TContext>;
}> & {
    mutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TContext>;
};

/**
 * @public
 */
export declare interface CreateBaseQueryOptions<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> extends QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey> {
}

/**
 * @public
 */
export declare type CreateBaseQueryResult<TData = unknown, TError = DefaultError, TState = QueryObserverResult<TData, TError>> = BaseQueryNarrowing<TData, TError> & MapToSignals<OmitKeyof<TState, keyof BaseQueryNarrowing, 'safely'>>;

/**
 * @public
 */
export declare interface CreateInfiniteQueryOptions<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryData = TQueryFnData, TQueryKey extends QueryKey = QueryKey, TPageParam = unknown> extends OmitKeyof<InfiniteQueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey, TPageParam>, 'suspense'> {
}

/**
 * @public
 */
export declare type CreateInfiniteQueryResult<TData = unknown, TError = DefaultError> = MapToSignals<InfiniteQueryObserverResult<TData, TError>>;

/**
 * @public
 */
export declare type CreateMutateAsyncFunction<TData = unknown, TError = DefaultError, TVariables = void, TContext = unknown> = MutateFunction<TData, TError, TVariables, TContext>;

/**
 * @public
 */
export declare type CreateMutateFunction<TData = unknown, TError = DefaultError, TVariables = void, TContext = unknown> = (...args: Parameters<MutateFunction<TData, TError, TVariables, TContext>>) => void;

/**
 * @public
 */
export declare interface CreateMutationOptions<TData = unknown, TError = DefaultError, TVariables = void, TContext = unknown> extends OmitKeyof<MutationObserverOptions<TData, TError, TVariables, TContext>, '_defaulted'> {
}

/**
 * @public
 */
export declare type CreateMutationResult<TData = unknown, TError = DefaultError, TVariables = unknown, TContext = unknown, TState = CreateStatusBasedMutationResult<CreateBaseMutationResult['status'], TData, TError, TVariables, TContext>> = BaseMutationNarrowing<TData, TError, TVariables, TContext> & MapToSignals<OmitKeyof<TState, keyof BaseMutationNarrowing, 'safely'>>;

/**
 * @public
 */
export declare interface CreateQueryOptions<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> extends OmitKeyof<CreateBaseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>, 'suspense'> {
}

/**
 * @public
 */
export declare type CreateQueryResult<TData = unknown, TError = DefaultError> = CreateBaseQueryResult<TData, TError>;

/**
 * @public
 */
declare type CreateStatusBasedMutationResult<TStatus extends CreateBaseMutationResult['status'], TData = unknown, TError = DefaultError, TVariables = unknown, TContext = unknown> = Extract<CreateBaseMutationResult<TData, TError, TVariables, TContext>, {
    status: TStatus;
}>;

/**
 * @public
 */
declare type CreateStatusBasedQueryResult<TStatus extends QueryObserverResult['status'], TData = unknown, TError = DefaultError> = Extract<QueryObserverResult<TData, TError>, {
    status: TStatus;
}>;

/**
 * @public
 */
export declare type DefinedCreateInfiniteQueryResult<TData = unknown, TError = DefaultError, TDefinedInfiniteQueryObserver = DefinedInfiniteQueryObserverResult<TData, TError>> = MapToSignals<TDefinedInfiniteQueryObserver>;

/**
 * @public
 */
export declare type DefinedCreateQueryResult<TData = unknown, TError = DefaultError, TDefinedQueryObserver = DefinedQueryObserverResult<TData, TError>> = MapToSignals<TDefinedQueryObserver>;

/**
 * @public
 */
export declare type DefinedInitialDataInfiniteOptions<TQueryFnData, TError = DefaultError, TData = InfiniteData<TQueryFnData>, TQueryKey extends QueryKey = QueryKey, TPageParam = unknown> = CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey, TPageParam> & {
    initialData: NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>> | (() => NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>);
};

/**
 * @public
 */
export declare type DefinedInitialDataOptions<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> = CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {
    initialData: NonUndefinedGuard<TQueryFnData> | (() => NonUndefinedGuard<TQueryFnData>);
};

declare type GetOptions<T> = T extends {
    queryFnData: infer TQueryFnData;
    error?: infer TError;
    data: infer TData;
} ? QueryObserverOptionsForCreateQueries<TQueryFnData, TError, TData> : T extends {
    queryFnData: infer TQueryFnData;
    error?: infer TError;
} ? QueryObserverOptionsForCreateQueries<TQueryFnData, TError> : T extends {
    data: infer TData;
    error?: infer TError;
} ? QueryObserverOptionsForCreateQueries<unknown, TError, TData> : T extends [infer TQueryFnData, infer TError, infer TData] ? QueryObserverOptionsForCreateQueries<TQueryFnData, TError, TData> : T extends [infer TQueryFnData, infer TError] ? QueryObserverOptionsForCreateQueries<TQueryFnData, TError> : T extends [infer TQueryFnData] ? QueryObserverOptionsForCreateQueries<TQueryFnData> : T extends {
    queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> | SkipTokenForUseQueries;
    select: (data: any) => infer TData;
    throwOnError?: ThrowOnError<any, infer TError, any, any>;
} ? QueryObserverOptionsForCreateQueries<TQueryFnData, unknown extends TError ? DefaultError : TError, unknown extends TData ? TQueryFnData : TData, TQueryKey> : QueryObserverOptionsForCreateQueries;

declare type GetResults<T> = T extends {
    queryFnData: any;
    error?: infer TError;
    data: infer TData;
} ? QueryObserverResult<TData, TError> : T extends {
    queryFnData: infer TQueryFnData;
    error?: infer TError;
} ? QueryObserverResult<TQueryFnData, TError> : T extends {
    data: infer TData;
    error?: infer TError;
} ? QueryObserverResult<TData, TError> : T extends [any, infer TError, infer TData] ? QueryObserverResult<TData, TError> : T extends [infer TQueryFnData, infer TError] ? QueryObserverResult<TQueryFnData, TError> : T extends [infer TQueryFnData] ? QueryObserverResult<TQueryFnData> : T extends {
    queryFn?: QueryFunction<infer TQueryFnData, any> | SkipTokenForUseQueries;
    select: (data: any) => infer TData;
    throwOnError?: ThrowOnError<any, infer TError, any, any>;
} ? QueryObserverResult<unknown extends TData ? TQueryFnData : TData, unknown extends TError ? DefaultError : TError> : QueryObserverResult;

/**
 * Allows to share and re-use infinite query options in a type-safe way.
 *
 * The `queryKey` will be tagged with the type from `queryFn`.
 * @param options - The infinite query options to tag with the type from `queryFn`.
 * @returns The tagged infinite query options.
 * @public
 */
export declare function infiniteQueryOptions<TQueryFnData, TError = DefaultError, TData = InfiniteData<TQueryFnData>, TQueryKey extends QueryKey = QueryKey, TPageParam = unknown>(options: DefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>): DefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam> & {
    queryKey: DataTag<TQueryKey, InfiniteData<TQueryFnData>>;
};

/**
 * Allows to share and re-use infinite query options in a type-safe way.
 *
 * The `queryKey` will be tagged with the type from `queryFn`.
 * @param options - The infinite query options to tag with the type from `queryFn`.
 * @returns The tagged infinite query options.
 * @public
 */
export declare function infiniteQueryOptions<TQueryFnData, TError = DefaultError, TData = InfiniteData<TQueryFnData>, TQueryKey extends QueryKey = QueryKey, TPageParam = unknown>(options: UndefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>): UndefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam> & {
    queryKey: DataTag<TQueryKey, InfiniteData<TQueryFnData>>;
};

/**
 * Injects an infinite query: a declarative dependency on an asynchronous source of data that is tied to a unique key.
 * Infinite queries can additively "load more" data onto an existing set of data or "infinite scroll"
 * @param optionsFn - A function that returns infinite query options.
 * @param injector - The Angular injector to use.
 * @returns The infinite query result.
 * @public
 */
export declare function injectInfiniteQuery<TQueryFnData, TError = DefaultError, TData = InfiniteData<TQueryFnData>, TQueryKey extends QueryKey = QueryKey, TPageParam = unknown>(optionsFn: (client: QueryClient) => DefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>, injector?: Injector): DefinedCreateInfiniteQueryResult<TData, TError>;

/**
 * Injects an infinite query: a declarative dependency on an asynchronous source of data that is tied to a unique key.
 * Infinite queries can additively "load more" data onto an existing set of data or "infinite scroll"
 * @param optionsFn - A function that returns infinite query options.
 * @param injector - The Angular injector to use.
 * @returns The infinite query result.
 * @public
 */
export declare function injectInfiniteQuery<TQueryFnData, TError = DefaultError, TData = InfiniteData<TQueryFnData>, TQueryKey extends QueryKey = QueryKey, TPageParam = unknown>(optionsFn: (client: QueryClient) => UndefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>, injector?: Injector): CreateInfiniteQueryResult<TData, TError>;

/**
 * Injects an infinite query: a declarative dependency on an asynchronous source of data that is tied to a unique key.
 * Infinite queries can additively "load more" data onto an existing set of data or "infinite scroll"
 * @param optionsFn - A function that returns infinite query options.
 * @param injector - The Angular injector to use.
 * @returns The infinite query result.
 * @public
 */
export declare function injectInfiniteQuery<TQueryFnData, TError = DefaultError, TData = InfiniteData<TQueryFnData>, TQueryKey extends QueryKey = QueryKey, TPageParam = unknown>(optionsFn: (client: QueryClient) => CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey, TPageParam>, injector?: Injector): CreateInfiniteQueryResult<TData, TError>;

/**
 * Injects a signal that tracks the number of queries that your application is loading or
 * fetching in the background.
 *
 * Can be used for app-wide loading indicators
 * @param filters - The filters to apply to the query.
 * @param injector - The Angular injector to use.
 * @returns signal with number of loading or fetching queries.
 * @public
 */
export declare function injectIsFetching(filters?: QueryFilters, injector?: Injector): Signal<number>;

/**
 * Injects a signal that tracks the number of mutations that your application is fetching.
 *
 * Can be used for app-wide loading indicators
 * @param filters - The filters to apply to the query.
 * @param injector - The Angular injector to use.
 * @returns signal with number of fetching mutations.
 * @public
 */
export declare function injectIsMutating(filters?: MutationFilters, injector?: Injector): Signal<number>;

/**
 * Injects a mutation: an imperative function that can be invoked which typically performs server side effects.
 *
 * Unlike queries, mutations are not run automatically.
 * @param optionsFn - A function that returns mutation options.
 * @param injector - The Angular injector to use.
 * @returns The mutation.
 * @public
 */
export declare function injectMutation<TData = unknown, TError = DefaultError, TVariables = void, TContext = unknown>(optionsFn: (client: QueryClient) => CreateMutationOptions<TData, TError, TVariables, TContext>, injector?: Injector): CreateMutationResult<TData, TError, TVariables, TContext>;

/**
 * Injects a signal that tracks the state of all mutations.
 * @param mutationStateOptionsFn - A function that returns mutation state options.
 * @param options - The Angular injector to use.
 * @returns The signal that tracks the state of all mutations.
 * @public
 */
export declare function injectMutationState<TResult = MutationState>(mutationStateOptionsFn?: () => MutationStateOptions<TResult>, options?: InjectMutationStateOptions): Signal<Array<TResult>>;

/**
 * @public
 */
export declare interface InjectMutationStateOptions {
    injector?: Injector;
}

/**
 * @public
 */
export declare function injectQueries<T extends Array<any>, TCombinedResult = QueriesResults<T>>({ queries, ...options }: {
    queries: Signal<[...QueriesOptions<T>]>;
    combine?: (result: QueriesResults<T>) => TCombinedResult;
}, injector?: Injector): Signal<TCombinedResult>;

/**
 * Injects a query: a declarative dependency on an asynchronous source of data that is tied to a unique key.
 *
 * **Basic example**
 * ```ts
 * class ServiceOrComponent {
 *   query = injectQuery(() => ({
 *     queryKey: ['repoData'],
 *     queryFn: () =>
 *       this.#http.get<Response>('https://api.github.com/repos/tanstack/query'),
 *   }))
 * }
 * ```
 *
 * Similar to `computed` from Angular, the function passed to `injectQuery` will be run in the reactive context.
 * In the example below, the query will be automatically enabled and executed when the filter signal changes
 * to a truthy value. When the filter signal changes back to a falsy value, the query will be disabled.
 *
 * **Reactive example**
 * ```ts
 * class ServiceOrComponent {
 *   filter = signal('')
 *
 *   todosQuery = injectQuery(() => ({
 *     queryKey: ['todos', this.filter()],
 *     queryFn: () => fetchTodos(this.filter()),
 *     // Signals can be combined with expressions
 *     enabled: !!this.filter(),
 *   }))
 * }
 * ```
 * @param optionsFn - A function that returns query options.
 * @param injector - The Angular injector to use.
 * @returns The query result.
 * @public
 * @see https://tanstack.com/query/latest/docs/framework/angular/guides/queries
 */
export declare function injectQuery<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(optionsFn: (client: QueryClient) => DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>, injector?: Injector): DefinedCreateQueryResult<TData, TError>;

/**
 * Injects a query: a declarative dependency on an asynchronous source of data that is tied to a unique key.
 *
 * **Basic example**
 * ```ts
 * class ServiceOrComponent {
 *   query = injectQuery(() => ({
 *     queryKey: ['repoData'],
 *     queryFn: () =>
 *       this.#http.get<Response>('https://api.github.com/repos/tanstack/query'),
 *   }))
 * }
 * ```
 *
 * Similar to `computed` from Angular, the function passed to `injectQuery` will be run in the reactive context.
 * In the example below, the query will be automatically enabled and executed when the filter signal changes
 * to a truthy value. When the filter signal changes back to a falsy value, the query will be disabled.
 *
 * **Reactive example**
 * ```ts
 * class ServiceOrComponent {
 *   filter = signal('')
 *
 *   todosQuery = injectQuery(() => ({
 *     queryKey: ['todos', this.filter()],
 *     queryFn: () => fetchTodos(this.filter()),
 *     // Signals can be combined with expressions
 *     enabled: !!this.filter(),
 *   }))
 * }
 * ```
 * @param optionsFn - A function that returns query options.
 * @param injector - The Angular injector to use.
 * @returns The query result.
 * @public
 * @see https://tanstack.com/query/latest/docs/framework/angular/guides/queries
 */
export declare function injectQuery<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(optionsFn: (client: QueryClient) => UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>, injector?: Injector): CreateQueryResult<TData, TError>;

/**
 * Injects a query: a declarative dependency on an asynchronous source of data that is tied to a unique key.
 *
 * **Basic example**
 * ```ts
 * class ServiceOrComponent {
 *   query = injectQuery(() => ({
 *     queryKey: ['repoData'],
 *     queryFn: () =>
 *       this.#http.get<Response>('https://api.github.com/repos/tanstack/query'),
 *   }))
 * }
 * ```
 *
 * Similar to `computed` from Angular, the function passed to `injectQuery` will be run in the reactive context.
 * In the example below, the query will be automatically enabled and executed when the filter signal changes
 * to a truthy value. When the filter signal changes back to a falsy value, the query will be disabled.
 *
 * **Reactive example**
 * ```ts
 * class ServiceOrComponent {
 *   filter = signal('')
 *
 *   todosQuery = injectQuery(() => ({
 *     queryKey: ['todos', this.filter()],
 *     queryFn: () => fetchTodos(this.filter()),
 *     // Signals can be combined with expressions
 *     enabled: !!this.filter(),
 *   }))
 * }
 * ```
 * @param optionsFn - A function that returns query options.
 * @param injector - The Angular injector to use.
 * @returns The query result.
 * @public
 * @see https://tanstack.com/query/latest/docs/framework/angular/guides/queries
 */
export declare function injectQuery<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(optionsFn: (client: QueryClient) => CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>, injector?: Injector): CreateQueryResult<TData, TError>;

/**
 * Injects the `QueryClient` instance into the component or service.
 *
 * **Example**
 * ```ts
 * const queryClient = injectQueryClient();
 * ```
 * @returns The `QueryClient` instance.
 * @public
 */
export declare const injectQueryClient: {
    (): QueryClient;
    (injectOptions: InjectOptions & {
        optional?: false;
    } & {
        injector?: Injector;
    }): QueryClient;
    (injectOptions: InjectOptions & {
        injector?: Injector;
    }): QueryClient;
};

declare type MapToSignals<T> = {
    [K in keyof T]: T[K] extends Function ? T[K] : Signal<T[K]>;
};

declare type MAXIMUM_DEPTH = 20;

declare type MutationStateOptions<TResult = MutationState> = {
    filters?: MutationFilters;
    select?: (mutation: Mutation) => TResult;
};

/**
 * @public
 */
export declare type NonUndefinedGuard<T> = T extends undefined ? never : T;

/**
 * Sets up providers necessary to enable TanStack Query functionality for Angular applications.
 *
 * Allows to configure a `QueryClient`.
 *
 * **Example - standalone**
 *
 * ```ts
 * import {
 *   provideAngularQuery,
 *   QueryClient,
 * } from '@tanstack/angular-query-experimental'
 *
 * bootstrapApplication(AppComponent, {
 *   providers: [provideAngularQuery(new QueryClient())],
 * })
 * ```
 *
 * **Example - NgModule-based**
 *
 * ```ts
 * import {
 *   provideAngularQuery,
 *   QueryClient,
 * } from '@tanstack/angular-query-experimental'
 *
 * @NgModule({
 *   declarations: [AppComponent],
 *   imports: [BrowserModule],
 *   providers: [provideAngularQuery(new QueryClient())],
 *   bootstrap: [AppComponent],
 * })
 * export class AppModule {}
 * ```
 * @param queryClient - A `QueryClient` instance.
 * @returns A set of providers to set up TanStack Query.
 * @public
 * @see https://tanstack.com/query/v5/docs/framework/angular/quick-start
 */
export declare function provideAngularQuery(queryClient: QueryClient): EnvironmentProviders;

/**
 * Usually {@link provideAngularQuery} is used once to set up TanStack Query and the
 * {@link https://tanstack.com/query/latest/docs/reference/QueryClient|QueryClient}
 * for the entire application. You can use `provideQueryClient` to provide a
 * different `QueryClient` instance for a part of the application.
 * @public
 */
export declare const provideQueryClient: ((value: QueryClient | (() => QueryClient)) => Provider) & ((value: QueryClient | (() => QueryClient)) => Provider);

/**
 * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param
 * @public
 */
export declare type QueriesOptions<T extends Array<any>, TResult extends Array<any> = [], TDepth extends ReadonlyArray<number> = []> = TDepth['length'] extends MAXIMUM_DEPTH ? Array<QueryObserverOptionsForCreateQueries> : T extends [] ? [] : T extends [infer Head] ? [...TResult, GetOptions<Head>] : T extends [infer Head, ...infer Tail] ? QueriesOptions<[
...Tail
], [
...TResult,
GetOptions<Head>
], [
...TDepth,
1
]> : ReadonlyArray<unknown> extends T ? T : T extends Array<QueryObserverOptionsForCreateQueries<infer TQueryFnData, infer TError, infer TData, infer TQueryKey>> ? Array<QueryObserverOptionsForCreateQueries<TQueryFnData, TError, TData, TQueryKey>> : Array<QueryObserverOptionsForCreateQueries>;

/**
 * QueriesResults reducer recursively maps type param to results
 * @public
 */
export declare type QueriesResults<T extends Array<any>, TResult extends Array<any> = [], TDepth extends ReadonlyArray<number> = []> = TDepth['length'] extends MAXIMUM_DEPTH ? Array<QueryObserverResult> : T extends [] ? [] : T extends [infer Head] ? [...TResult, GetResults<Head>] : T extends [infer Head, ...infer Tail] ? QueriesResults<[
...Tail
], [
...TResult,
GetResults<Head>
], [
...TDepth,
1
]> : T extends Array<QueryObserverOptionsForCreateQueries<infer TQueryFnData, infer TError, infer TData, any>> ? Array<QueryObserverResult<unknown extends TData ? TQueryFnData : TData, unknown extends TError ? DefaultError : TError>> : Array<QueryObserverResult>;

declare type QueryObserverOptionsForCreateQueries<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> = OmitKeyof<QueryObserverOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>, 'placeholderData'> & {
    placeholderData?: TQueryFnData | QueriesPlaceholderDataFunction<TQueryFnData>;
};

/**
 * Allows to share and re-use query options in a type-safe way.
 *
 * The `queryKey` will be tagged with the type from `queryFn`.
 *
 * **Example**
 *
 * ```ts
 *  const { queryKey } = queryOptions({
 *     queryKey: ['key'],
 *     queryFn: () => Promise.resolve(5),
 *     //  ^?  Promise<number>
 *   })
 *
 *   const queryClient = new QueryClient()
 *   const data = queryClient.getQueryData(queryKey)
 *   //    ^?  number | undefined
 * ```
 * @param options - The query options to tag with the type from `queryFn`.
 * @returns The tagged query options.
 * @public
 */
export declare function queryOptions<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>): DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & {
    queryKey: DataTag<TQueryKey, TQueryFnData>;
};

/**
 * Allows to share and re-use query options in a type-safe way.
 *
 * The `queryKey` will be tagged with the type from `queryFn`.
 *
 * **Example**
 *
 * ```ts
 *  const { queryKey } = queryOptions({
 *     queryKey: ['key'],
 *     queryFn: () => Promise.resolve(5),
 *     //  ^?  Promise<number>
 *   })
 *
 *   const queryClient = new QueryClient()
 *   const data = queryClient.getQueryData(queryKey)
 *   //    ^?  number | undefined
 * ```
 * @param options - The query options to tag with the type from `queryFn`.
 * @returns The tagged query options.
 * @public
 */
export declare function queryOptions<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>): UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & {
    queryKey: DataTag<TQueryKey, TQueryFnData>;
};

declare type SignalFunction<T extends () => any> = T & Signal<ReturnType<T>>;

declare type SkipTokenForUseQueries = symbol;

/**
 * @public
 */
export declare type UndefinedInitialDataInfiniteOptions<TQueryFnData, TError = DefaultError, TData = InfiniteData<TQueryFnData>, TQueryKey extends QueryKey = QueryKey, TPageParam = unknown> = CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey, TPageParam> & {
    initialData?: undefined;
};

/**
 * @public
 */
export declare type UndefinedInitialDataOptions<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> = CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {
    initialData?: undefined | InitialDataFunction<NonUndefinedGuard<TQueryFnData>>;
};


export * from "@tanstack/query-core";

export { }
